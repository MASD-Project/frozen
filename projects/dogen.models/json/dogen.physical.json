{
  "documentation": "The pysical model defines the core entities that make up the\nphysical dimension of MASD conceptual space.\n",
  "tagged_values": {
    "masd.codec.dia.comment": "true",
    "masd.codec.model_modules": "dogen.physical",
    "masd.codec.input_technical_space": "cpp",
    "masd.codec.reference": "cpp.builtins",
    "masd.codec.reference": "cpp.std",
    "masd.codec.reference": "cpp.boost",
    "masd.codec.reference": "dogen.tracing",
    "masd.codec.reference": "dogen.variability",
    "masd.codec.reference": "dogen",
    "masd.codec.reference": "masd",
    "masd.codec.reference": "masd.variability",
    "masd.codec.reference": "dogen.profiles",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "main",
      "stereotypes": [
        "masd::entry_point",
        "dogen::untypable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "CMakeLists",
      "stereotypes": [
        "masd::build::cmakelists",
        "dogen::handcrafted::cmake"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers",
      "documentation": "Helpers for the physical model.\n",
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "helpers::template_instantiation_domains_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::building_error",
      "documentation": "An error occurred while the field factory was building.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities",
      "documentation": "Defines the MASD physical space.\n",
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "entities::meta_model",
      "documentation": "Describes the geometry of physical space.\n\nProvides details of the backends available in the current instance of Dogen.\n",
      "stereotypes": [
        "ContainingMetaElement"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "template_instantiation_domains",
          "type": "std::unordered_map<std::string, std::vector<std::string>>",
          "documentation": "Provides all of the domains to be used for template instantiation.\n\nExample of a domain is \"masd.facet\" which contains the list of all available facets.\nTemplates (facet and profile) are then instantiated over this range, depending on\nuser choices.\n"
        },
        {
          "name": "backends",
          "type": "std::list<backend>",
          "documentation": "All backends available in this meta-model.\n"
        },
        {
          "name": "indexed_names",
          "type": "identification::entities::physical_meta_name_indices",
          "documentation": "Repository with all the meta-names in this meta-model, indexed appropriately.\n"
        }
      ]
    },
    {
      "name": "entities::backend",
      "documentation": "Represents a meta-region in physical space with archetypes for a primary technical\nspace, and associated secondary technical spaces.\n",
      "stereotypes": [
        "ContainingMetaElement",
        "HasTechnicalSpace"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "parts",
          "type": "std::unordered_map<identification::entities::physical_meta_id, part>",
          "documentation": "Parts by part ID.\n"
        },
        {
          "name": "facets",
          "type": "std::unordered_map<identification::entities::physical_meta_id, facet>",
          "documentation": "Facets by facet ID.\n"
        },
        {
          "name": "archetypes",
          "type": "std::unordered_map<identification::entities::physical_meta_id, archetype>",
          "documentation": "Archetypes by archetype ID.\n"
        },
        {
          "name": "archetype_kinds",
          "type": "std::unordered_map<std::string, archetype_kind>",
          "documentation": "Archetype kinds by ID.\n"
        }
      ]
    },
    {
      "name": "entities::part",
      "documentation": "Represents a meta-region in physical space with archetypes for a given part of a\ncomponent in a backend.\n",
      "stereotypes": [
        "ContainingMetaElement"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "path_configuration",
          "type": "path_configuration"
        },
        {
          "name": "facets",
          "type": "std::unordered_map<identification::entities::physical_meta_id, facet>"
        },
        {
          "name": "archetypes",
          "type": "std::unordered_map<identification::entities::physical_meta_id, archetype>"
        },
        {
          "name": "requires_relative_path",
          "type": "bool",
          "documentation": "If true, this part needs a path relative to its root.\n"
        }
      ]
    },
    {
      "name": "entities::path_configuration",
      "documentation": "Describes how paths are handled within a part.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules",
          "type": "path_contribution_type",
          "documentation": "What kind of contribution do the external modules make to the final path.\n"
        },
        {
          "name": "model_modules",
          "type": "path_contribution_type",
          "documentation": "What kind of contribution do the model modules make to the final path.\n"
        },
        {
          "name": "facet",
          "type": "path_contribution_type",
          "documentation": "What kind of contribution does the facet make to the final path.\n"
        },
        {
          "name": "internal_modules",
          "type": "path_contribution_type",
          "documentation": "What kind of contribution do the internal modules make to the final path.\n"
        }
      ]
    },
    {
      "name": "entities::path_contribution_type",
      "documentation": "Different kinds of contributions that can be made to the final path computation.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "none",
          "type": "",
          "documentation": "The item does not contribute at all to the path.\n"
        },
        {
          "name": "as_directories",
          "type": "",
          "documentation": "The item contributes folders to the path.\n"
        },
        {
          "name": "as_path_components",
          "type": "",
          "documentation": "The item contributes a single folder to the path, as a delimited string.\n"
        }
      ]
    },
    {
      "name": "entities::facet",
      "documentation": "Represents a meta-region in physical space with archetypes for a given theme.\n",
      "stereotypes": [
        "ContainingMetaElement",
        "Postfixable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "archetypes",
          "type": "std::unordered_map<identification::entities::physical_meta_id, archetype>"
        },
        {
          "name": "helpers",
          "type": "std::unordered_map<identification::entities::physical_meta_id, helper>"
        },
        {
          "name": "default_archetype_for_logical_meta_model_id",
          "type": "std::unordered_map<std::string, archetype>",
          "documentation": "Maps the logical model element ID to the default archetype for this facet.\n\nUsed to obtain the default archetype for referencing.\n"
        }
      ]
    },
    {
      "name": "entities::archetype",
      "documentation": "Represents a meta-artefact.\n",
      "stereotypes": [
        "MetaElement",
        "Postfixable",
        "Associatable",
        "HasTechnicalSpace"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "archetype_kind_id",
          "type": "std::string",
          "documentation": "ID for the archetype kind that this archetype is an instance of.\n"
        },
        {
          "name": "logical_meta_element_id",
          "type": "identification::entities::logical_meta_id",
          "documentation": "ID of the meta-element in the logical model this archetype binds to.\n"
        },
        {
          "name": "part",
          "type": "identification::entities::physical_meta_id",
          "documentation": "Part in which we are located.\n"
        },
        {
          "name": "relations",
          "type": "relations",
          "documentation": "Properties of this archetype with regards to relations.\n"
        }
      ]
    },
    {
      "name": "entities::archetype_kind",
      "documentation": "Represents a type of archetypes.\n",
      "stereotypes": [
        "Describable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "id",
          "type": "std::string"
        },
        {
          "name": "file_extension",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "entities::model",
      "documentation": "Collection of entities representing objects in physical space.\n",
      "stereotypes": [
        "Element"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "technical_space",
          "type": "std::string",
          "documentation": "Primary technical space that this model belongs to.\n"
        },
        {
          "name": "managed_directories",
          "type": "std::list<boost::filesystem::path>"
        },
        {
          "name": "outputting_properties",
          "type": "outputting_properties"
        },
        {
          "name": "orphan_artefacts",
          "type": "std::list<boost::shared_ptr<physical::entities::artefact>>",
          "documentation": "Artefacts that exist in the physical dimension only.\n"
        },
        {
          "name": "meta_model_properties",
          "type": "meta_model_properties",
          "documentation": "Meta-model configuration supplied by this model.\n"
        },
        {
          "name": "has_generatable_artefacts",
          "type": "bool",
          "documentation": "If true the repository has at least one generable artefact, false otherwise.\n"
        },
        {
          "name": "regions_by_logical_id",
          "type": "std::unordered_map<identification::entities::logical_id, region>",
          "documentation": "All physical regions in  this model, by logical ID.\n"
        }
      ]
    },
    {
      "name": "entities::Describable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "description",
          "type": "std::string",
          "documentation": "Human readable description of the entity.\n"
        }
      ]
    },
    {
      "name": "entities::MetaNameable",
      "documentation": "Ability to have a meta-name.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "meta_name",
          "type": "identification::entities::physical_meta_name",
          "documentation": "Meta-name for this meta-element.\n"
        }
      ]
    },
    {
      "name": "entities::Labelable",
      "documentation": "The ability to attach labels to an element.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "labels",
          "type": "std::list<identification::entities::label>",
          "documentation": "All labels associated with this element.\n"
        }
      ]
    },
    {
      "name": "entities::MetaElement",
      "parents": [
        "entities::Describable",
        "entities::MetaNameable",
        "entities::Labelable"
      ],
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::ContainingMetaElement",
      "parents": [
        "entities::MetaElement"
      ],
      "documentation": "The meta-element can contain other meta-elements.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory_name",
          "type": "std::string",
          "documentation": "Default name to use for the directory in the file-system representing this element.\n"
        }
      ]
    },
    {
      "name": "entities::Postfixable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "postfix",
          "type": "std::string",
          "documentation": "Postfix to apply to artefacts within this element, if any.\n"
        }
      ]
    },
    {
      "name": "features",
      "documentation": "Features for the MASD physical model.\n",
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "features::facet_features",
      "documentation": "Physical features common to all facets.\n",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.instantiation_domain_name": "masd.facet"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory_name",
          "type": "masd::variability::text",
          "value": "\"\"",
          "documentation": "Directory in which to place this facet.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global",
            "masd.variability.default_value_override.cpp.types": "\"types\"",
            "masd.variability.default_value_override.cpp.hash": "\"hash\"",
            "masd.variability.default_value_override.cpp.tests": "\"generated_tests\"",
            "masd.variability.default_value_override.cpp.io": "\"io\"",
            "masd.variability.default_value_override.cpp.lexical_cast": "\"lexical_cast\"",
            "masd.variability.default_value_override.cpp.templates": "\"templates\"",
            "masd.variability.default_value_override.cpp.odb": "\"odb\"",
            "masd.variability.default_value_override.cpp.test_data": "\"test_data\"",
            "masd.variability.default_value_override.cpp.serialization": "\"serialization\"",
            "masd.variability.default_value_override.csharp.types": "\"Types\"",
            "masd.variability.default_value_override.csharp.io": "\"Dumpers\"",
            "masd.variability.default_value_override.csharp.test_data": "\"SequenceGenerators\""
          }
        },
        {
          "name": "postfix",
          "type": "masd::variability::text",
          "value": "\"\"",
          "documentation": "Postfix to use for all files that belong to this facet.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global",
            "masd.variability.default_value_override.cpp.tests": "\"tests\"",
            "masd.variability.default_value_override.cpp.hash": "\"hash\"",
            "masd.variability.default_value_override.cpp.lexical_cast": "\"lc\"",
            "masd.variability.default_value_override.cpp.io": "\"io\"",
            "masd.variability.default_value_override.cpp.odb": "\"pragmas\"",
            "masd.variability.default_value_override.cpp.test_data": "\"td\"",
            "masd.variability.default_value_override.cpp.serialization": "\"ser\"",
            "masd.variability.default_value_override.csharp.io": "\"Dumper\"",
            "masd.variability.default_value_override.csharp.test_data": "\"SequenceGenerator\""
          }
        },
        {
          "name": "overwrite",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, the generated files will overwrite existing files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "features::archetype_features",
      "documentation": "Features common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.instantiation_domain_name": "masd.archetype"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "postfix",
          "type": "masd::variability::text",
          "value": "\"\"",
          "documentation": "Postfix to use for all files that belong to this facet.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global",
            "masd.variability.default_value_override.forward_declarations": "\"fwd\"",
            "masd.variability.default_value_override.factory": "\"factory\"",
            "masd.variability.default_value_override.transform": "\"transform\""
          }
        },
        {
          "name": "overwrite",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, the generated files will overwrite existing files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "features::initializer",
      "stereotypes": [
        "masd::variability::initializer"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::path_generator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::artefact",
      "documentation": "Represents an entity in physical space.\n",
      "stereotypes": [
        "Element",
        "HasTechnicalSpace"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the file corresponding to this artefact.\n"
        },
        {
          "name": "content",
          "type": "std::string",
          "documentation": "Textual content of the artefact.\n"
        },
        {
          "name": "path_properties",
          "type": "path_properties",
          "documentation": "Properties related to paths in the filesystem.\n"
        },
        {
          "name": "dependencies",
          "type": "std::vector<boost::filesystem::path>",
          "documentation": "Files in the project directory that this file depends on, but which are not generated.\n"
        },
        {
          "name": "unified_diff",
          "type": "std::string",
          "documentation": "Unified diff between the in-memory artefact and the file in the filesystem.\n"
        },
        {
          "name": "operation",
          "type": "operation",
          "documentation": "Operation to be applied to this artefact.\n"
        },
        {
          "name": "enablement_properties",
          "type": "enablement_properties",
          "documentation": "Stores the properties related to the enablement, as read out from configuration.\n"
        },
        {
          "name": "formatting_input",
          "type": "std::string",
          "documentation": "Template used as input in order to generate the artefact's content, if any.\n"
        },
        {
          "name": "relations",
          "type": "relation_properties"
        }
      ]
    },
    {
      "name": "entities::Configurable",
      "documentation": "Ability to have meta-data associated.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "configuration",
          "type": "boost::shared_ptr<variability::entities::configuration>",
          "documentation": "Configuration for this element.\n"
        }
      ]
    },
    {
      "name": "entities::Provenance",
      "documentation": "Properties related to the origin of the modeling element.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "provenance",
          "type": "identification::entities::logical_provenance",
          "documentation": "Details of the provenance of this model element.\n"
        }
      ]
    },
    {
      "name": "entities::Nameable",
      "documentation": "Ability to have a name.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "name",
          "type": "identification::entities::physical_name",
          "documentation": "Name of the physical element.\n"
        }
      ]
    },
    {
      "name": "entities::LogicalPhysicalSpaceIdentity",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "id",
          "type": "identification::entities::logical_meta_physical_id",
          "documentation": "Point in logical-physical space represented by this element.\n"
        }
      ]
    },
    {
      "name": "entities::Element",
      "parents": [
        "entities::MetaNameable",
        "entities::Configurable",
        "entities::Provenance",
        "entities::Nameable",
        "entities::LogicalPhysicalSpaceIdentity"
      ],
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::outputting_properties",
      "documentation": "Properties related to outputting.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "force_write",
          "type": "bool"
        },
        {
          "name": "delete_extra_files",
          "type": "bool"
        },
        {
          "name": "ignore_files_matching_regex",
          "type": "std::vector<std::string>"
        },
        {
          "name": "delete_empty_directories",
          "type": "bool"
        }
      ]
    },
    {
      "name": "entities::operation",
      "documentation": "Operation to apply to an artefact.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "type",
          "type": "operation_type"
        },
        {
          "name": "reason",
          "type": "operation_reason"
        }
      ]
    },
    {
      "name": "entities::operation_type",
      "documentation": "Operation to perform to a given artefact.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "tagged_values": {
        "masd.cpp.hash.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "create_only",
          "type": "",
          "documentation": "Creates a file from an artefact only if it does not yet exist.\n"
        },
        {
          "name": "write",
          "type": "",
          "documentation": "Unconditionally writes an artefact into file.\n"
        },
        {
          "name": "ignore",
          "type": "",
          "documentation": "Ingores an artefact.\n"
        },
        {
          "name": "remove",
          "type": "",
          "documentation": "Deletes a file.\n"
        }
      ]
    },
    {
      "name": "entities::operation_reason",
      "documentation": "Reasons for performing an operation.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "tagged_values": {
        "masd.cpp.hash.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "newly_generated",
          "type": "",
          "documentation": "Artefact will produce a new generated file.\n"
        },
        {
          "name": "changed_generated",
          "type": "",
          "documentation": "Artefact will produce a changed generated file.\n"
        },
        {
          "name": "unchanged_generated",
          "type": "",
          "documentation": "Generated artefact contents match file contents.\n"
        },
        {
          "name": "already_exists",
          "type": "",
          "documentation": "The file already exists and we we're asked to create only.\n"
        },
        {
          "name": "ignore_generated",
          "type": "",
          "documentation": "User requested artefact to be ignored.\n"
        },
        {
          "name": "force_write",
          "type": "",
          "documentation": "User requested to always write generated artefacts.\n"
        },
        {
          "name": "unexpected",
          "type": "",
          "documentation": "Artefact represents an unexpected file in project.\n"
        },
        {
          "name": "ignore_unexpected",
          "type": "",
          "documentation": "File is unexpected but the user asked us not to delete it.\n"
        },
        {
          "name": "ignore_regex",
          "type": "",
          "documentation": "File is unexpected but the user asked us to ignore it via regexes.\n"
        }
      ]
    },
    {
      "name": "helpers::file_status_collector",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::files_by_status",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "unexpected",
          "type": "std::list<boost::filesystem::path>"
        },
        {
          "name": "ignored",
          "type": "std::list<boost::filesystem::path>"
        }
      ]
    },
    {
      "name": "helpers::unified_differ",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "features::filesystem",
      "documentation": "Features related to filesystem operations.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "global",
        "masd.variability.key_prefix": "masd.physical"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "force_write",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, artefacts are always written to the filesystem.\n\nIf false, the system will check to see if writing is needed by performing a binary\ndiff. If no changes are detected, no writting is performed.\n"
        },
        {
          "name": "delete_extra_files",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, any files the code generator is not aware of are deleted.\n\nIf you'd like to skip the deletion of certain files, set  \"ignore_files_matching_regex\" accordingly.\n"
        },
        {
          "name": "ignore_files_matching_regex",
          "type": "masd::variability::text_collection",
          "documentation": "Regular expressions to filter files prior to deletion.\n\nOnly applicable if \"delete_extra_files\" is enabled.\n",
          "tagged_values": {
            "masd.variability.is_optional": "true"
          }
        },
        {
          "name": "delete_empty_directories",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, all directories without any files will be deleted.\n\nThis setting is recursive: if a directory is composed of one or more directories that\nare themselves empty, the entire directory tree is deleted.\n"
        },
        {
          "name": "enable_backend_directories",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, a directory is created for each technical space targeted.\n\nNote that this setting is only relevant if you are targetting a single output technical\nspace. If you are targetting more than one, it will automatically be set to true.\n"
        }
      ]
    },
    {
      "name": "transforms",
      "documentation": "Contains all of the transforms needed to produce\nmodels and meta-models for the physical model.\n",
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::context",
      "stereotypes": [
        "dogen::typeable",
        "dogen::pretty_printable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "diffing_configuration",
          "type": "boost::optional<diffing_configuration>"
        },
        {
          "name": "reporting_configuration",
          "type": "boost::optional<reporting_configuration>"
        },
        {
          "name": "dry_run_mode_enabled",
          "type": "bool"
        },
        {
          "name": "feature_model",
          "type": "boost::shared_ptr<variability::entities::feature_model>"
        },
        {
          "name": "meta_model",
          "type": "boost::shared_ptr<entities::meta_model>",
          "documentation": "Meta-model for the physical dimension.\n"
        },
        {
          "name": "tracer",
          "type": "boost::shared_ptr<tracing::tracer>"
        },
        {
          "name": "output_directory_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the output directory chosen by the user.\n"
        }
      ]
    },
    {
      "name": "transforms::transform_exception",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::file_generation_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::write_artefacts_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::update_outputting_properties_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::remove_files_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::generate_report_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::model_post_processing_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::generate_diffs_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::gather_external_artefacts_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::generate_patch_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::mock_content_filler_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::operation_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "registrar",
      "stereotypes": [
        "masd::serialization::type_registrar"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "features::enablement",
      "documentation": "Enablement related properties.\n",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "any",
        "masd.variability.generate_static_configuration": "false",
        "masd.variability.instantiation_domain_name": "masd"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, decorations are enabled on this modeling element.\n"
        }
      ]
    },
    {
      "name": "helpers::meta_model_validator",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "helpers::validation_error",
      "documentation": "An error occurred during validation.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::Associatable",
      "documentation": "The meta-element is associated with other meta-elements\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "depends",
          "type": "std::list<std::string>",
          "documentation": "List of meta-elements this meta-element depends upon, if any.\n"
        },
        {
          "name": "generates",
          "type": "std::list<std::string>",
          "documentation": "List of meta-elements this meta-element is used to generate, if any.\n"
        },
        {
          "name": "generated_by",
          "type": "std::string",
          "documentation": "Meta-element used to generate this meta-element, if any.\n"
        }
      ]
    },
    {
      "name": "transforms::merge_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::model_set",
      "documentation": "Represents a set of related physical models.\n",
      "stereotypes": [
        "Nameable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "models",
          "type": "std::list<model>",
          "documentation": "All models that are a member of this set.\n"
        }
      ]
    },
    {
      "name": "transforms::meta_model_production_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::compute_name_indices_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::minimal_context",
      "documentation": "Smallest possible context required for bootstrapping purposes.\n",
      "stereotypes": [
        "dogen::typeable",
        "dogen::pretty_printable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "tracer",
          "type": "boost::shared_ptr<tracing::tracer>"
        }
      ]
    },
    {
      "name": "entities::relation_status",
      "documentation": "Status of a given archetype with regards to being related to other archetypes.\n",
      "stereotypes": [
        "masd::enumeration",
        "dogen::convertible"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "not_relatable",
          "type": "",
          "documentation": "Archertype cannot be legally related to other archetypes.\n"
        },
        {
          "name": "relatable",
          "type": "",
          "documentation": "Archetype can be related to archetypes.\n"
        },
        {
          "name": "facet_default",
          "type": "",
          "documentation": "FIXME: hack for now\n"
        }
      ]
    },
    {
      "name": "transforms::meta_model_assembly_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::compute_template_instantiation_domains",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::constant_relation",
      "documentation": "Represents a relation between archetypes, fixed to a logical model element.\n",
      "stereotypes": [
        "Urnable",
        "Labelable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "logical_model_element_id",
          "type": "std::string",
          "documentation": "ID of the logical model element that the relation is fixed against.\n\nElement must exist in the current loaded models.\n"
        }
      ]
    },
    {
      "name": "entities::variable_relation",
      "stereotypes": [
        "Urnable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "type",
          "type": "variable_relation_type",
          "documentation": "How these archetypes are related.\n"
        }
      ]
    },
    {
      "name": "entities::Urnable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "original_urn",
          "type": "std::string",
          "documentation": "URN which may or may not be an archetype URN.\n\n It must have the form \"archetype:\" if pointing to an archetype, or  \"label:\" if \npointing to a label, and then is followed by \"KEY:VALUE\". The label must resolve\nto a unique archetype.\n"
        },
        {
          "name": "resolved_urn",
          "type": "std::string",
          "documentation": "URN pointing to the archetype.\n\n It must have the form \"archetype:\".\n"
        }
      ]
    },
    {
      "name": "entities::variable_relation_type",
      "documentation": "Lists all of the valid variable relation types.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "self",
          "type": "",
          "documentation": "Logical element is related to itself across different projections.\n"
        },
        {
          "name": "parent",
          "type": "",
          "documentation": "Parent of logical element.\n"
        },
        {
          "name": "child",
          "type": "",
          "documentation": "Child of logical element.\n"
        },
        {
          "name": "transparent",
          "type": "",
          "documentation": "The relation with another logical element requires the element's full definition.\n"
        },
        {
          "name": "opaque",
          "type": "",
          "documentation": "The relation with another logical element does not requires its full definition.\n"
        },
        {
          "name": "associative_key",
          "type": "",
          "documentation": "The associated element is used as an associative key.\n"
        },
        {
          "name": "visitation",
          "type": "",
          "documentation": "The associated element visits or is visited by the current element.\n"
        }
      ]
    },
    {
      "name": "entities::relations",
      "documentation": "Models relationships between archetypes.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "status",
          "type": "relation_status",
          "documentation": "Status of this archetype with regards to being related to archetypes.\n"
        },
        {
          "name": "constant",
          "type": "std::list<constant_relation>",
          "documentation": "All archetypes this archetype is related to,  over a fixed logical meta-model\nelement.\n"
        },
        {
          "name": "variable",
          "type": "std::list<variable_relation>",
          "documentation": "All archetypes this archetype is related to,  over a variable logical meta-model\nelement.\n"
        },
        {
          "name": "hard_coded",
          "type": "std::list<hard_coded_relation>"
        }
      ]
    },
    {
      "name": "entities::hard_coded_relation",
      "documentation": "Relations against hard-coded values.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "value",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "entities::region",
      "documentation": "Represents a region of logical-physical space fixed at one logical point.\n",
      "stereotypes": [
        "Configurable",
        "Provenance"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "artefacts_by_archetype",
          "type": "std::unordered_map<identification::entities::physical_meta_id, boost::shared_ptr<physical::entities::artefact>>",
          "documentation": "All artefacts that are contained within this set, organised by archetype.\n"
        },
        {
          "name": "archetype_for_role",
          "type": "std::unordered_map<std::string, identification::entities::physical_meta_id>",
          "documentation": "Resolves a role into a concrete archetype, in the context of this logical element.\n"
        },
        {
          "name": "is_generatable",
          "type": "bool",
          "documentation": "If false, the entire artefact set is not generatable.\n"
        }
      ]
    },
    {
      "name": "entities::enablement_properties",
      "documentation": "Stores the properties related to the enablement.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool",
          "documentation": "If true, the artefact is enabled and its content will be computed.\n\nThe enabled flag is computed from the configuration read out.\n"
        },
        {
          "name": "overwrite",
          "type": "bool",
          "documentation": "If true, the artefact will be expressed to the filesystem if there are changes.\n\nThe overwrite flag is computed from the configuration read out.\n"
        },
        {
          "name": "facet_enabled",
          "type": "boost::optional<bool>",
          "documentation": "If supplied and true, the facet is enabled.\n"
        },
        {
          "name": "archetype_enabled",
          "type": "boost::optional<bool>",
          "documentation": "If supplied and true, the archetype is enabled.\n"
        },
        {
          "name": "facet_overwrite",
          "type": "boost::optional<bool>",
          "documentation": "If supplied and true, the facet will have overwrite on.\n"
        },
        {
          "name": "archetype_overwrite",
          "type": "boost::optional<bool>",
          "documentation": "If supplied and true, the archetype will have overwrite on.\n"
        }
      ]
    },
    {
      "name": "transforms::model_population_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::meta_model_properties_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::enablement_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::generability_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::backend_properties",
      "documentation": "Properties related to the backend.\n",
      "stereotypes": [
        "MetaIdentifiable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool",
          "documentation": "If true, the backend is enabled.\n"
        },
        {
          "name": "file_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the backend.\n"
        },
        {
          "name": "technical_space_version",
          "type": "std::string",
          "documentation": "Technical space version to use.\n"
        },
        {
          "name": "enable_backend_directories",
          "type": "bool",
          "documentation": "Copy of the component level configuration for backend directory enablement.\n"
        },
        {
          "name": "directory_name",
          "type": "std::string",
          "documentation": "Directory name as read out from the configuration.\n"
        },
        {
          "name": "computed_directory_name",
          "type": "std::string",
          "documentation": "Name of the directory to use for the backend, computed from configuration.\n"
        }
      ]
    },
    {
      "name": "entities::archetype_kind_properties",
      "stereotypes": [
        "MetaNameable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_extension",
          "type": "std::string"
        }
      ]
    },
    {
      "name": "entities::facet_properties",
      "documentation": "Properties related to the facet.\n",
      "stereotypes": [
        "MetaIdentifiable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool",
          "documentation": "If true, the facet is enabled.\n"
        },
        {
          "name": "overwrite",
          "type": "bool",
          "documentation": "If true, all archetypes in this facet will be set to overwrite.\n"
        },
        {
          "name": "directory_name",
          "type": "std::string",
          "documentation": "Directory name as read out from the configuration.\n"
        },
        {
          "name": "computed_directory_name",
          "type": "std::string",
          "documentation": "Computed name of the directory to use for the facet.\n"
        },
        {
          "name": "postfix",
          "type": "std::string",
          "documentation": "Postfix as read out from the configuration, if any.\n"
        },
        {
          "name": "computed_postfix",
          "type": "std::string",
          "documentation": "Computed postfix to apply to all artefacts in this facet.\n"
        }
      ]
    },
    {
      "name": "entities::archetype_properties",
      "documentation": "Properties related to the archetype.\n",
      "stereotypes": [
        "MetaIdentifiable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "enabled",
          "type": "bool",
          "documentation": "If true, the archetype is enabled.\n"
        },
        {
          "name": "overwrite",
          "type": "boost::optional<bool>",
          "documentation": "If true, all artefacts for this archetype will be set to overwrite.\n"
        },
        {
          "name": "postfix",
          "type": "std::string",
          "documentation": "Postfix as read out from the configuration.\n"
        },
        {
          "name": "computed_postfix",
          "type": "std::string",
          "documentation": "Computed postfix to apply to all artefacts of this archetype.\n"
        },
        {
          "name": "backend_properties",
          "type": "backend_properties"
        },
        {
          "name": "facet_properties",
          "type": "facet_properties"
        },
        {
          "name": "part_properties",
          "type": "part_properties"
        }
      ]
    },
    {
      "name": "entities::meta_model_properties",
      "documentation": "Meta-model configuration supplied by this model.\n\nThe meta-model properties represent a set of variability overrides supplied on top\nof the existing physical meta-model. In addition, the properties also contain \ncomputed values on the back of physical transforms.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "output_directory_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the output directory chosen by the user.\n"
        },
        {
          "name": "file_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the component.\n"
        },
        {
          "name": "backend_properties",
          "type": "std::unordered_map<identification::entities::physical_meta_id, backend_properties>"
        },
        {
          "name": "facet_properties",
          "type": "std::unordered_map<identification::entities::physical_meta_id, facet_properties>"
        },
        {
          "name": "archetype_properties",
          "type": "std::unordered_map<identification::entities::physical_meta_id, archetype_properties>"
        },
        {
          "name": "archetype_kind_properties",
          "type": "std::unordered_map<identification::entities::physical_meta_id, archetype_kind_properties>"
        },
        {
          "name": "part_properties",
          "type": "std::unordered_map<identification::entities::physical_meta_id, part_properties>"
        },
        {
          "name": "enabled_backends",
          "type": "std::unordered_set<identification::entities::physical_meta_id>",
          "documentation": "Contains the IDs of all of the backends which are enabled.\n"
        },
        {
          "name": "enabled_archetype_for_element",
          "type": "std::unordered_set<identification::entities::logical_meta_physical_id>"
        },
        {
          "name": "project_path_properties",
          "type": "project_path_properties"
        }
      ]
    },
    {
      "name": "entities::part_properties",
      "documentation": "Properties related to the part.\n",
      "stereotypes": [
        "MetaIdentifiable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the facet.\n"
        },
        {
          "name": "relative_path",
          "type": "boost::filesystem::path",
          "documentation": "Path to the part, relative to the component directory.\n\nOnly required when the part is located outside of the component directory.\n"
        },
        {
          "name": "directory_name",
          "type": "std::string",
          "documentation": "Directory name as read out from the configuration.\n"
        },
        {
          "name": "computed_directory_name",
          "type": "std::string",
          "documentation": "Computed name of the directory to use for the part.\n"
        }
      ]
    },
    {
      "name": "transforms::paths_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::path_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_path",
          "type": "boost::filesystem::path",
          "documentation": "Full path to the file corresponding to this artefact.\n"
        },
        {
          "name": "header_guard",
          "type": "std::string",
          "documentation": "C++ header guard for this artefact, if any,\n"
        },
        {
          "name": "inclusion_path",
          "type": "boost::filesystem::path",
          "documentation": "Path for inclusion for this artefact, computed from the path.\n\nNote that this is will not necessarily be used for the inclusion directive.\n"
        },
        {
          "name": "inclusion_directives",
          "type": "inclusion_directives"
        },
        {
          "name": "inclusion_dependencies",
          "type": "std::list<std::string>",
          "documentation": "C++ Inlusion dependencies for this artefact.\n"
        },
        {
          "name": "using_dependencies",
          "type": "std::list<std::string>"
        },
        {
          "name": "relative_path",
          "type": "boost::filesystem::path"
        }
      ]
    },
    {
      "name": "transforms::remove_regions_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "features::backend_features",
      "documentation": "Physical features common to all backends.\n",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.instantiation_domain_name": "masd.backend"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "directory_name",
          "type": "masd::variability::text",
          "value": "\"\"",
          "documentation": "Directory in which to place this backend.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global",
            "masd.variability.default_value_override.cpp": "\"cpp\"",
            "masd.variability.default_value_override.csharp": "\"cs\""
          }
        }
      ]
    },
    {
      "name": "entities::project_path_properties",
      "documentation": "Legacy type containing all proprties related to paths.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "include_directory_name",
          "type": "std::string"
        },
        {
          "name": "source_directory_name",
          "type": "std::string"
        },
        {
          "name": "disable_facet_directories",
          "type": "bool"
        },
        {
          "name": "header_file_extension",
          "type": "std::string"
        },
        {
          "name": "implementation_file_extension",
          "type": "std::string"
        },
        {
          "name": "tests_directory_name",
          "type": "std::string"
        },
        {
          "name": "templates_directory_name",
          "type": "std::string"
        },
        {
          "name": "templates_file_extension",
          "type": "std::string"
        },
        {
          "name": "enable_unique_file_names",
          "type": "bool"
        },
        {
          "name": "headers_output_directory",
          "type": "std::string",
          "documentation": "Directory in which to place C++ header files. Must be a relative path.\n"
        },
        {
          "name": "enable_backend_directories",
          "type": "bool",
          "documentation": "If true, backends should have backend-specific directories to store their artefacts.\n"
        },
        {
          "name": "implementation_directory_full_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "include_directory_full_path",
          "type": "boost::filesystem::path"
        },
        {
          "name": "templates_directory_full_path",
          "type": "boost::filesystem::path"
        }
      ]
    },
    {
      "name": "features::path_features",
      "documentation": "Set of features related to path processing.\n",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.generate_static_configuration": "true",
        "masd.variability.key_prefix": "masd.cpp"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "headers_output_directory",
          "type": "masd::variability::text",
          "documentation": "Override location of public c++ headers.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global",
            "masd.variability.is_optional": "true"
          }
        },
        {
          "name": "source_directory_name",
          "type": "masd::variability::text",
          "value": "\"src\"",
          "documentation": "Directory in which to place C++ source files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "include_directory_name",
          "type": "masd::variability::text",
          "value": "\"include\"",
          "documentation": "Directory in which to place include headers.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "tests_directory_name",
          "type": "masd::variability::text",
          "value": "\"generated_tests\"",
          "documentation": "Directory in which to place c++ tests.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "templates_directory_name",
          "type": "masd::variability::text",
          "value": "\"templates\"",
          "documentation": "Directory in which to place text templates.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "header_file_extension",
          "type": "masd::variability::text",
          "value": "\"hpp\"",
          "documentation": "Extension to use for C++ header files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "implementation_file_extension",
          "type": "masd::variability::text",
          "value": "\"cpp\"",
          "documentation": "Extension to use for C++ implementation files.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "templates_file_extension",
          "type": "masd::variability::text",
          "value": "\"wale\"",
          "documentation": "Extension to use for text templates.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "enable_unique_file_names",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, make all file names unique within a model.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        },
        {
          "name": "disable_facet_directories",
          "type": "masd::variability::boolean",
          "value": "\"false\"",
          "documentation": "If true, facet directories will not be used.\n",
          "tagged_values": {
            "masd.variability.binding_point": "global"
          }
        }
      ]
    },
    {
      "name": "entities::MetaIdentifiable",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "meta_id",
          "type": "identification::entities::physical_meta_id",
          "documentation": "Meta-id of the physical meta-element.\n"
        }
      ]
    },
    {
      "name": "transforms::legacy_paths_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::legacy_archetype_kind",
      "documentation": "Kinds of archetypes available across all technical spaces.\n",
      "stereotypes": [
        "masd::enumeration"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "visual_studio_solution",
          "type": ""
        },
        {
          "name": "visual_studio_project",
          "type": ""
        },
        {
          "name": "odb_options",
          "type": ""
        },
        {
          "name": "msbuild_targets",
          "type": ""
        },
        {
          "name": "tests_cmakelists",
          "type": ""
        },
        {
          "name": "source_cmakelists",
          "type": ""
        },
        {
          "name": "include_cmakelists",
          "type": ""
        },
        {
          "name": "cpp_header",
          "type": ""
        },
        {
          "name": "cpp_implementation",
          "type": ""
        },
        {
          "name": "tests_cpp_main",
          "type": ""
        },
        {
          "name": "tests_cpp_implementation",
          "type": ""
        },
        {
          "name": "templates",
          "type": ""
        },
        {
          "name": "csharp_implementation",
          "type": ""
        }
      ]
    },
    {
      "name": "entities::relation_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "status",
          "type": "relation_status"
        },
        {
          "name": "relations",
          "type": "std::list<std::string>",
          "documentation": "Artefacts that this artefact depends on.\n\nThe format used is dependent on the technical space the artefact belongs to.\n"
        }
      ]
    },
    {
      "name": "transforms::relations_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "features::directive_features",
      "stereotypes": [
        "masd::variability::feature_template_bundle"
      ],
      "tagged_values": {
        "masd.variability.default_binding_point": "element",
        "masd.variability.instantiation_domain_name": "masd.cpp.archetype"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "primary_inclusion_directive",
          "type": "masd::variability::text"
        },
        {
          "name": "secondary_inclusion_directive",
          "type": "masd::variability::text_collection"
        }
      ]
    },
    {
      "name": "features::inclusion_features",
      "stereotypes": [
        "masd::variability::feature_bundle"
      ],
      "tagged_values": {
        "masd.variability.generate_static_configuration": "false",
        "masd.variability.key_prefix": "masd.cpp"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "inclusion_required",
          "type": "masd::variability::boolean",
          "value": "\"true\"",
          "documentation": "If true, inclusion is required for this modeling element.\n",
          "tagged_values": {
            "masd.variability.binding_point": "element"
          }
        }
      ]
    },
    {
      "name": "helpers::header_guard_factory",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::inclusion_directives",
      "documentation": "Represents the group of inclusion directives associated with a name and an archetype.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "primary",
          "type": "std::string",
          "documentation": "The main inclusion directive needed for this element.\n"
        },
        {
          "name": "secondary",
          "type": "std::list<std::string>",
          "documentation": "Any other directives that are also needed for this element.\n"
        }
      ]
    },
    {
      "name": "entities::HasTechnicalSpace",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "technical_space",
          "type": "identification::entities::technical_space",
          "documentation": "Technical space to which this physical element belongs to.\n"
        }
      ]
    },
    {
      "name": "entities::helper",
      "stereotypes": [
        "MetaElement",
        "Associatable",
        "HasTechnicalSpace"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "relations",
          "type": "relations",
          "documentation": "Properties of this helper with regards to relations.\n"
        },
        {
          "name": "part",
          "type": "identification::entities::physical_meta_id",
          "documentation": "Part in which we are located.\n"
        },
        {
          "name": "family",
          "type": "std::string"
        },
        {
          "name": "owning_formatters",
          "type": "std::list<identification::entities::physical_meta_id>"
        },
        {
          "name": "owning_facets",
          "type": "std::list<identification::entities::physical_meta_id>"
        }
      ]
    }
  ]
}
