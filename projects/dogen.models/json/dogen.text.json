{
  "documentation": "Contains all of the M2T transforms for all supported backends.\n",
  "tagged_values": {
    "masd.codec.dia.comment": "true",
    "masd.codec.model_modules": "dogen.text",
    "masd.codec.reference": "cpp.builtins",
    "masd.codec.reference": "cpp.boost",
    "masd.codec.reference": "cpp.std",
    "masd.codec.reference": "dogen",
    "masd.codec.reference": "dogen.variability",
    "masd.codec.reference": "dogen.tracing",
    "masd.codec.reference": "dogen.logical",
    "masd.codec.reference": "masd",
    "masd.codec.reference": "masd.variability",
    "masd.codec.reference": "dogen.profiles",
    "masd.codec.input_technical_space": "cpp",
    "masd.variability.profile": "dogen.profiles.base.default_profile"
  },
  "elements": [
    {
      "name": "entities",
      "fallback_element_type": "masd::module"
    },
    {
      "name": "entities::model",
      "documentation": "Represents the combined logical-physical space.\n",
      "stereotypes": [
        "Provenance"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "logical",
          "type": "logical::entities::model",
          "documentation": "The logical model representation in the logical-physical space.\n"
        },
        {
          "name": "physical",
          "type": "physical::entities::model",
          "documentation": "The physical model representation in the logical-physical space.\n"
        },
        {
          "name": "logical_physical_regions",
          "type": "std::list<logical_physical_region>",
          "documentation": "Contains all of the logical-physical regions that make up the logical physical space\nfor this model.\n"
        }
      ]
    },
    {
      "name": "transforms",
      "documentation": "Contains all of the text transforms available.\n",
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::model_to_text_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::model_generation_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::context",
      "stereotypes": [
        "dogen::typeable",
        "dogen::pretty_printable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "physical_meta_model",
          "type": "boost::shared_ptr<physical::entities::meta_model>",
          "documentation": "Meta-model for the physical dimension.\n"
        },
        {
          "name": "output_directory_path",
          "type": "boost::filesystem::path",
          "documentation": "FIXME: to be removed\n"
        },
        {
          "name": "tracer",
          "type": "boost::shared_ptr<tracing::tracer>"
        },
        {
          "name": "generation_timestamp",
          "type": "std::string",
          "documentation": "Human readable timestamp of when the generation took place.\n"
        }
      ]
    },
    {
      "name": "transforms::transformation_error",
      "documentation": "An error occurred whilst applying a transformation.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::registrar_error",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters",
      "fallback_element_type": "masd::module"
    },
    {
      "name": "formatters::formatting_error",
      "documentation": "An error has occurred while formatting.\n",
      "stereotypes": [
        "masd::exception"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::namespace_formatter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::scoped_namespace_formatter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::boilerplate_formatter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::scoped_boilerplate_formatter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::dependencies_formatter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::header_guard_formatter",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::boilerplate_properties",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "preamble",
          "type": "std::string"
        },
        {
          "name": "postamble",
          "type": "std::string"
        },
        {
          "name": "dependencies",
          "type": "std::list<std::string>"
        },
        {
          "name": "header_guard",
          "type": "std::string"
        },
        {
          "name": "technical_space",
          "type": "identification::entities::technical_space"
        },
        {
          "name": "generate_preamble",
          "type": "bool"
        },
        {
          "name": "generate_header_guards",
          "type": "bool"
        }
      ]
    },
    {
      "name": "entities::Provenance",
      "documentation": "Details of the origin of this model element.\n",
      "stereotypes": [
        "masd::object_template"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "provenance",
          "type": "identification::entities::logical_provenance",
          "documentation": "Details of the provenance of this model element.\n"
        }
      ]
    },
    {
      "name": "registrar",
      "stereotypes": [
        "masd::serialization::type_registrar"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "main",
      "stereotypes": [
        "masd::entry_point",
        "dogen::untypable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "CMakeLists",
      "stereotypes": [
        "masd::build::cmakelists",
        "dogen::handcrafted::cmake"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::logical_physical_region",
      "documentation": "Represents a region of logical-physical space with a single logical element and\nits associated physical elements.\n",
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "logical_element",
          "type": "boost::shared_ptr<logical::entities::element>",
          "documentation": "Logical element that gives rise to the artefact.\n"
        },
        {
          "name": "physical_region",
          "type": "physical::entities::region",
          "documentation": "Physical artefacts that will be produced from the logical element.\n"
        }
      ]
    },
    {
      "name": "transforms::model_to_text_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable",
        "dogen::pretty_printable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "entities::model_set",
      "documentation": "Represents a set of related models.\n",
      "stereotypes": [
        "Provenance"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "models",
          "type": "std::list<model>",
          "documentation": "Models that belong to this set.\n"
        }
      ]
    },
    {
      "name": "cpp_artefact_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "namespace {\n\nconst std::string transform_id(\"{{containing_namespace}}.{{archetype.simple_name}}_transform\");\n\nusing namespace dogen::utility::log;\nauto lg(logger_factory(transform_id));\n\n}\n\nconst physical::entities::archetype& {{archetype.simple_name}}_transform::static_archetype() {\n    static auto r({{archetype.simple_name}}_factory::make());\n    return r;\n}\n\nconst physical::entities::archetype& {{archetype.simple_name}}_transform::archetype() const {\n    return static_archetype();\n}\n"
        }
      ]
    },
    {
      "name": "transforms::cpp",
      "documentation": "Text transforms that implement the C++ backend.\n\nProvides a set of M2T transforms that convert logical\nmodel elements into a physical representation in the\nC++ technical space, or associated minor technical spaces.\n",
      "stereotypes": [
        "masd::physical::backend"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.backend_name": "cpp",
        "masd.physical.directory_name": "cpp",
        "masd.physical.major_technical_space": "cpp",
        "masd.physical.technical_space": "cpp",
        "masd.label.test": "lbl"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::implementation",
      "documentation": "Contains the implementation files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        },
        {
          "name": "directory_name",
          "type": "",
          "value": "src"
        }
      ]
    },
    {
      "name": "transforms::cpp::public_headers",
      "documentation": "Contains the header files that are publicly visible.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "true"
        },
        {
          "name": "directory_name",
          "type": "",
          "value": "include"
        }
      ]
    },
    {
      "name": "transforms::cpp::testing",
      "documentation": "Contains the generated test files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        },
        {
          "name": "directory_name",
          "type": "",
          "value": "generated_tests"
        }
      ]
    },
    {
      "name": "transforms::cpp::standard_header_file",
      "documentation": "Header file generated by Dogen.\n",
      "stereotypes": [
        "masd::physical::archetype_kind"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "file_extension",
          "type": "",
          "value": "hpp"
        }
      ]
    },
    {
      "name": "transforms::helper_transform",
      "stereotypes": [
        "dogen::handcrafted::typeable",
        "dogen::pretty_printable"
      ],
      "tagged_values": {
        "masd.cpp.types.class_forward_declarations.enabled": "true"
      },
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::helper_chain",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "physical_model",
          "type": "physical::entities::meta_model"
        }
      ]
    },
    {
      "name": "transforms::helper_repository",
      "stereotypes": [
        "dogen::typeable",
        "dogen::pretty_printable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "helpers_by_family",
          "type": "std::unordered_map<std::string, std::unordered_map<identification::entities::physical_meta_id, std::list<std::shared_ptr<helper_transform>>>>"
        }
      ]
    },
    {
      "name": "transforms::helper_registrar",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "repository_",
          "type": "helper_repository"
        }
      ]
    },
    {
      "name": "transforms::cpp::types",
      "documentation": "M2T transforms for the types facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.label.test": "some_label",
        "masd.physical.directory_name": "types"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::types::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::base_archetype_configuration",
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.technical_space",
          "type": "",
          "value": "cpp"
        }
      ]
    },
    {
      "name": "transforms::cpp::tests_configuration",
      "parents": [
        "transforms::cpp::base_archetype_configuration"
      ],
      "documentation": "Contains the configuration common to most archetypes in tests.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::tests_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.cpp.testing"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        },
        {
          "name": "masd.physical.relation_status",
          "type": "",
          "value": "not_relatable"
        }
      ]
    },
    {
      "name": "transforms::cpp::header_configuration",
      "parents": [
        "transforms::cpp::base_archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all c++ header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.cpp.public_headers"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        }
      ]
    },
    {
      "name": "transforms::cpp::header_facet_default_configuration",
      "parents": [
        "transforms::cpp::header_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::header_facet_default_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.relation_status",
          "type": "",
          "value": "facet_default"
        }
      ]
    },
    {
      "name": "transforms::cpp::enumeration_header_configuration",
      "parents": [
        "transforms::cpp::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all enumeration header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum_header"
        }
      ]
    },
    {
      "name": "transforms::cpp::object_header_configuration",
      "parents": [
        "transforms::cpp::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all object header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class_header"
        }
      ]
    },
    {
      "name": "transforms::cpp::primitive_header_configuration",
      "parents": [
        "transforms::cpp::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all built header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive_header"
        }
      ]
    },
    {
      "name": "transforms::cpp::builtin_header_configuration",
      "parents": [
        "transforms::cpp::header_facet_default_configuration"
      ],
      "documentation": "Contains the configuration common to all built header archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::builtin_header_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.builtin"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "builtin_header"
        }
      ]
    },
    {
      "name": "transforms::cpp::implementation_configuration",
      "parents": [
        "transforms::cpp::base_archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all c++ implementation archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.cpp.implementation"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "cpp_artefact_transform_implementation"
        },
        {
          "name": "masd.physical.relation_status",
          "type": "",
          "value": "not_relatable"
        }
      ]
    },
    {
      "name": "transforms::cpp::object_implementation_configuration",
      "parents": [
        "transforms::cpp::implementation_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class_implementation"
        }
      ]
    },
    {
      "name": "transforms::cpp::primitive_implementation_configuration",
      "parents": [
        "transforms::cpp::implementation_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive_implementation"
        }
      ]
    },
    {
      "name": "transforms::cpp::enumeration_implementation_configuration",
      "parents": [
        "transforms::cpp::implementation_configuration"
      ],
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_implementation_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum_implementation"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash",
      "documentation": "M2T transforms for the hash facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "hash",
        "masd.physical.postfix": "hash"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::hash::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::build",
      "documentation": "M2T transforms related to build files.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::io",
      "documentation": "M2T transforms for the io facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "io",
        "masd.physical.postfix": "io"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::visual_studio",
      "documentation": "M2T transforms related to Visual Studio\nsupport.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::serialization",
      "documentation": "M2T transforms for the boost serialisation\nfacet of the C++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "serialization",
        "masd.physical.postfix": "ser"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::test_data",
      "documentation": "M2T transforms for the test data facet\nof the C++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "test_data",
        "masd.physical.postfix": "td"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::tests",
      "documentation": "M2T transforms that generate tests for\ngenerated code, in the C++ technical space.\n\n\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "generated_tests",
        "masd.physical.postfix": "tests"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::odb",
      "documentation": "M2T transforms for the ODB facet of the\nC++ technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "odb",
        "masd.physical.postfix": "odb"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::lexical_cast",
      "documentation": "M2T transforms related to conversions from\nand to string.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "lexical_cast",
        "masd.physical.postfix": "lx"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::cpp::build::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::io::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::odb::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::lexical_cast::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::visual_studio::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::serialization::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::test_data::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::tests::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::csharp",
      "documentation": "M2T transforms for the C# technical space.\n\nTakes types in the logical model and creates text\nrepresentations of the these types according to the grammar\nof the C# technical space.\n",
      "stereotypes": [
        "masd::physical::backend"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.backend_name": "csharp",
        "masd.physical.directory_name": "cs",
        "masd.physical.major_technical_space": "csharp",
        "masd.physical.technical_space": "csharp"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::csharp::archetype_configuration",
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::archetype_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.part_id",
          "type": "",
          "value": "masd.csharp.implementation"
        },
        {
          "name": "masd.physical.wale_template_reference",
          "type": "",
          "value": "csharp_transform_implementation"
        },
        {
          "name": "masd.physical.relation_status",
          "type": "",
          "value": "facet_default"
        },
        {
          "name": "masd.physical.technical_space",
          "type": "",
          "value": "csharp"
        }
      ]
    },
    {
      "name": "transforms::csharp::primitive_configuration",
      "parents": [
        "transforms::csharp::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::primitive_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.primitive"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "primitive"
        }
      ]
    },
    {
      "name": "transforms::csharp::enumeration_configuration",
      "parents": [
        "transforms::csharp::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::enumeration_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.enumeration"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "enum"
        }
      ]
    },
    {
      "name": "transforms::csharp::object_configuration",
      "parents": [
        "transforms::csharp::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::object_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.object"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "class"
        }
      ]
    },
    {
      "name": "transforms::csharp::exception_configuration",
      "parents": [
        "transforms::csharp::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::exception_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.exception"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "exception"
        }
      ]
    },
    {
      "name": "transforms::csharp::builtin_configuration",
      "parents": [
        "transforms::csharp::archetype_configuration"
      ],
      "documentation": "Contains the configuration common to all archetypes.\n",
      "stereotypes": [
        "masd::variability::profile"
      ],
      "tagged_values": {
        "masd.variability.binding_point": "entity",
        "masd.variability.stereotype": "dogen::builtin_configuration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "masd.physical.logical_meta_element_id",
          "type": "",
          "value": "dogen.logical.entities.builtin"
        },
        {
          "name": "masd.wale.kvp.archetype.simple_name",
          "type": "",
          "value": "builtin"
        }
      ]
    },
    {
      "name": "transforms::csharp::implementation",
      "documentation": "Contains the implementation files.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "as_path_components"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "as_directories"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::csharp::types",
      "documentation": "M2T transforms for the types facet of\nthe C# technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "Types"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::csharp::io",
      "documentation": "M2T transforms for the io facet of the\nC# technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "Dumpers",
        "masd.physical.postfix": "Dumper"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::csharp::test_data",
      "documentation": "M2T transforms for the test data facet of\nthe C# technical space.\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true",
        "masd.physical.directory_name": "SequenceGenerators",
        "masd.physical.postfix": "SequenceGenerator"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::csharp::visual_studio",
      "documentation": "M2T transforms for the visual studio\nfacet of the C# technical space.\n\n\n",
      "stereotypes": [
        "masd::physical::facet"
      ],
      "tagged_values": {
        "masd.codec.dia.comment": "true"
      },
      "fallback_element_type": "masd::module"
    },
    {
      "name": "transforms::csharp::types::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::csharp::io::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::csharp::test_data::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::csharp::visual_studio::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "csharp_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "namespace {\n\nconst std::string transform_id(\"{{containing_namespace}}.{{archetype.simple_name}}_transform\");\n\nusing namespace dogen::utility::log;\nauto lg(logger_factory(transform_id));\n\n}\n\nconst physical::entities::archetype& {{archetype.simple_name}}_transform::static_archetype() {\n    static auto r({{archetype.simple_name}}_factory::make());\n    return r;\n}\n\nconst physical::entities::archetype& {{archetype.simple_name}}_transform::archetype() const {\n    return static_archetype();\n}\n"
        }
      ]
    },
    {
      "name": "csharp_helper_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<{{facet.qualified_name}}>\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        \"{{facet.qualified_name}}.class\",\n        \"{{facet.qualified_name}}.primitive\"\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        \"{{facet.qualified_name}}\"\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(\n    const physical::entities::model& /*m*/,\n    const logical::entities::element& /*e*/,\n    const physical::entities::artefact& /*a*/,\n    const logical::entities::helper_properties& /*hp*/) const {\n    return true;\n}\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::csharp::initializer",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::types::smart_pointer_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "smart_pointer_helper_transform",
        "masd.wale.kvp.helper.family": "SmartPointer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.types",
        "masd.physical.helpers.family": "SmartPointer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/smart_pointer_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid smart_pointer_helper_transform::apply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto qn(d.name_tree_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n#>\n\ninline bool operator==(const <#= qn #>& lhs,\nconst <#= qn #>& rhs) {\n    return (!lhs && !rhs) ||(lhs && rhs && (*lhs == *rhs));\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_implementation",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<{{facet.qualified_name}}>\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        \"{{facet.qualified_name}}.class_implementation\",\n        \"{{facet.qualified_name}}.primitive_implementation\",\n        \"masd.cpp.types.class_implementation\",\n        \"masd.cpp.types.primitive_implementation\"\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        \"{{facet.qualified_name}}\", \"masd.cpp.types\"\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(\n    const physical::entities::model& m,\n    const logical::entities::element& e,\n    const physical::entities::artefact& a,\n    const logical::entities::helper_properties& hp) const {\n    return is_streaming_enabled(m, e, a, hp);\n}\n"
        }
      ]
    },
    {
      "name": "cpp_helper_transform_implementation_enabled",
      "stereotypes": [
        "masd::templating::logic_less_templates"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "content",
          "type": "",
          "documentation": "std::string {{class.simple_name}}::id() const {\n    static auto r(std::string(\"<{{facet.qualified_name}}>\") +\n        std::string(\"<\") + helper_name() + std::string(\">\"));\n    return r;\n}\n\nstd::string {{class.simple_name}}::family() const {\n    static std::string r(\"{{helper.family}}\");\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_formatters() const {\n    static auto r(std::list<std::string> {\n        \"{{facet.qualified_name}}.class_implementation\",\n        \"{{facet.qualified_name}}.primitive_implementation\"\n    });\n    return r;\n}\n\nstd::list<std::string>\n{{class.simple_name}}::owning_facets() const {\n    static auto r(std::list<std::string> {\n        \"{{facet.qualified_name}}\"\n    });\n    return r;\n}\n\nstd::string {{class.simple_name}}::helper_name() const {\n    static std::string r(\"{{class.simple_name}}\");\n    return r;\n}\n\nbool {{class.simple_name}}::is_enabled(\n    const physical::entities::model& /*m*/,\n    const logical::entities::element& /*e*/,\n    const physical::entities::artefact& /*a*/,\n    const logical::entities::helper_properties& /*hp*/) const {\n    return true;\n}\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::date_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "date_helper_transform",
        "masd.wale.kvp.helper.family": "BoostDate",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "BoostDate",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/date_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid date_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    combine(seed, v.modjulian_day());\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::ptime_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "ptime_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPTime",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "BoostPTime",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/ptime_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid ptime_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    const boost::posix_time::ptime epoch(boost::gregorian::date(1970, 1, 1));\n    boost::posix_time::time_duration d(v - epoch);\n    seed = static_cast<std::size_t>(d.total_seconds());\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::associative_container_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "associative_container_helper_transform",
        "masd.wale.kvp.helper.family": "AssociativeContainer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "AssociativeContainer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/associative_container_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid associative_container_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n\n    if (hp.direct_descendants().size() == 2) {\n        const auto key(hp.direct_descendants().front());\n        const auto value(hp.direct_descendants().back());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    for (const auto& i : v) {\n<#+\n        if (!key.requires_hashing_helper())\n#>\n        combine(seed, i.first);\n<#+\n        else\n#>\n        combine(seed, hash_<#= key.name_tree_identifiable() #>(i.first));\n<#+\n\n        if (!(value.requires_hashing_helper()))\n#>\n        combine(seed, i.second);\n<#+\n        else\n#>\n        combine(seed, hash_<#= value.name_tree_identifiable() #>(i.second));\n    }\n    return seed;\n}\n<#+\n    } else {\n        const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    for (const auto& i : v) {\n<#+\n    if (!containee.requires_hashing_helper())\n#>\n        combine(seed, i);\n<#+\n    else\n#>\n        combine(seed, hash_<#= containee.name_tree_identifiable() #>(i));\n    }\n    return seed;\n}\n<#+\n    }\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::optional_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "optional_helper_transform",
        "masd.wale.kvp.helper.family": "Optional",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "Optional",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/optional_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid optional_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n\n    if (!v)\n        return seed;\n\n<#+\n    if (!containee.requires_hashing_helper())\n#>\n    combine(seed, *v);\n<#+\n    else\n#>\n    combine(seed, hash_<#= containee.name_tree_identifiable() #>(*v));\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::sequence_container_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "sequence_container_helper_transform",
        "masd.wale.kvp.helper.family": "SequenceContainer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "SequenceContainer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/sequence_container_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid sequence_container_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    for (const auto& i : v) {\n<#+\n    if (!containee.requires_hashing_helper())\n#>\n        combine(seed, i);\n<#+\n    else\n#>\n        combine(seed, hash_<#= containee.name_tree_identifiable() #>(i));\n    }\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::variant_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "variant_helper_transform",
        "masd.wale.kvp.helper.family": "BoostVariant",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "BoostVariant",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/variant_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid variant_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto key(hp.direct_descendants().front());\n    const auto value(hp.direct_descendants().back());\n#>\n\nstruct <#= ident #>_visitor : public boost::static_visitor<> {\n    <#= ident #>_visitor() : hash(0) {}\n<#+\n    for (const auto& dd : hp.direct_descendants()) {\n#>\n    void operator()(const <#= dd.name_qualified() #><#= (dd.is_simple_type() ? \"\" : \"&\") #> v) const {\n<#+\n        if (!dd.requires_hashing_helper())\n#>\n        combine(hash, v);\n<#+\n        else\n#>\n        combine(hash, hash_<#= dd.name_tree_identifiable() #>(v));\n    }\n\n<#+\n    }\n#>\n    mutable std::size_t hash;\n};\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    <#= ident #>_visitor vis;\n    boost::apply_visitor(vis, v);\n    return vis.hash;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::time_duration_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "time_duration_helper_transform",
        "masd.wale.kvp.helper.family": "BoostTimeDuration",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "BoostTimeDuration",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/time_duration_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid time_duration_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    seed = static_cast<std::size_t>(v.total_seconds());\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::ptree_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "ptree_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPTree",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "BoostPTree",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/ptree_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid ptree_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    for (const auto& node : v) {\n        combine(seed, node.first);\n        combine(seed, node.second.data());\n        combine(seed, hash_<#= ident #>(node.second));\n    }\n\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::pair_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "pair_helper_transform",
        "masd.wale.kvp.helper.family": "Pair",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "Pair",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/pair_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid pair_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto first(hp.direct_descendants().front());\n    const auto second(hp.direct_descendants().back());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n\n<#+\n    if (!first.requires_hashing_helper())\n#>\n    combine(seed, v.first);\n<#+\n    else\n#>\n    combine(seed, hash_<#= first.name_tree_identifiable() #>(v.first));\n<#+\n\n    if (!second.requires_hashing_helper())\n#>\n    combine(seed, v.second);\n<#+\n    else\n#>\n    combine(seed, hash_<#= second.name_tree_identifiable() #>(v.second));\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::smart_pointer_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "smart_pointer_helper_transform",
        "masd.wale.kvp.helper.family": "SmartPointer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "SmartPointer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/smart_pointer_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid smart_pointer_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n<#+\n    if (!containee.requires_hashing_helper())\n#>\n    combine(seed, *v);\n<#+\n    else\n#>\n    combine(seed, hash_<#= containee.name_tree_identifiable() #>(*v));\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::path_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "path_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPath",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.hash",
        "masd.physical.helpers.family": "BoostPath",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.hash.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/path_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid path_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\ninline std::size_t hash_<#= ident #>(const <#= qn #>& v) {\n    std::size_t seed(0);\n    combine(seed, v.generic_string());\n    return seed;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::optional_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "optional_helper_transform",
        "masd.wale.kvp.helper.family": "Optional",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "Optional",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/optional_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid optional_helper_transform::\napply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto nt_qn(d.name_tree_qualified());\n        const auto n_qn(d.name_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n        const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {\n    s << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= n_qn #>\\\"\" << \", \";\n\n    if (v)\n        s << \"\\\"data\\\": \" << <#= streaming_for_type(containee, \"*v\") #>;\n    else\n        s << \"\\\"data\\\": \"\"\\\"<null>\\\"\";\n    s << \" }\";\n    return s;\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::pair_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "pair_helper_transform",
        "masd.wale.kvp.helper.family": "Pair",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "Pair",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/pair_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid pair_helper_transform::apply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto nt_qn(d.name_tree_qualified());\n        const auto n_qn(d.name_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n        const auto first(hp.direct_descendants().front());\n        const auto second(hp.direct_descendants().back());\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {\n    s << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= n_qn #>\\\"\" << \", \";\n\n    s << \"\\\"first\\\": \" << <#= streaming_for_type(first, \"v.first\") #> << \", \";\n    s << \"\\\"second\\\": \" << <#= streaming_for_type(second, \"v.second\") #>;\n    s << \" }\";\n    return s;\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::string_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "string_helper_transform",
        "masd.wale.kvp.helper.family": "String",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "String",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/string_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid string_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& /*hp*/) const {\n#>\ninline std::string tidy_up_string(std::string s) {\n    boost::replace_all(s, \"\\r\\n\", \"<new_line>\");\n    boost::replace_all(s, \"\\n\", \"<new_line>\");\n    boost::replace_all(s, \"\\\"\", \"<quote>\");\n    boost::replace_all(s, \"\\\\\", \"<backslash>\");\n    return s;\n}\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::ptree_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "ptree_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPTree",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "BoostPTree",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/ptree_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid ptree_helper_transform::apply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto nt_qn(d.name_tree_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {\n    std::ostringstream ss;\n    boost::property_tree::write_json(ss, v);\n\n    std::string content(ss.str());\n    boost::replace_all(content, \"\\r\\n\", \"\");\n    boost::replace_all(content, \"\\n\", \"\");\n\n    s << content;\n    return s;\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::associative_container_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "associative_container_helper_transform",
        "masd.wale.kvp.helper.family": "AssociativeContainer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "AssociativeContainer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/associative_container_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid associative_container_helper_transform::\napply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto qn(d.name_tree_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n\n        if (hp.direct_descendants().size() == 2) {\n            const auto key(hp.direct_descendants().front());\n            const auto value(hp.direct_descendants().back());\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= qn #>& v) {\n    s << \"[\";\n    for (auto i(v.begin()); i != v.end(); ++i) {\n        if (i != v.begin()) s << \", \";\n        s << \"[ { \" << \"\\\"__type__\\\": \" << \"\\\"key\\\"\" << \", \" << \"\\\"data\\\": \";\n        s << <#= streaming_for_type(key, \"i->first\") #>;\n        s << \" }, { \" << \"\\\"__type__\\\": \" << \"\\\"value\\\"\" << \", \" << \"\\\"data\\\": \";\n        s << <#= streaming_for_type(value, \"i->second\") #>;\n        s << \" } ]\";\n    }\n    s << \" ] \";\n    return s;\n}\n\n<#+\n        } else {\n        const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= qn #>& v) {\n    s << \"[ \";\n    for (auto i(v.begin()); i != v.end(); ++i) {\n        if (i != v.begin()) s << \", \";\n        s << <#= streaming_for_type(containee, \"*i\") #>;\n    }\n    s << \"] \";\n    return s;\n}\n\n<#+\n        }\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::sequence_container_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "sequence_container_helper_transform",
        "masd.wale.kvp.helper.family": "SequenceContainer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "SequenceContainer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/sequence_container_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid sequence_container_helper_transform::apply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto qn(d.name_tree_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n        const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= qn #>& v) {\n    s << \"[ \";\n    for (auto i(v.begin()); i != v.end(); ++i) {\n        if (i != v.begin()) s << \", \";\n        s << <#= streaming_for_type(containee, \"*i\") #>;\n    }\n    s << \"] \";\n    return s;\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::smart_pointer_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "smart_pointer_helper_transform",
        "masd.wale.kvp.helper.family": "SmartPointer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "SmartPointer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/smart_pointer_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid smart_pointer_helper_transform::apply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto nt_qn(d.name_tree_qualified());\n        const auto n_qn(d.name_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n        const auto containee(hp.direct_descendants().front());\n#>\n\ninline std::ostream& operator<<(std::ostream& s, const <#= nt_qn #>& v) {\n    s << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= n_qn #>\\\"\" << \", \"\n      << \"\\\"memory\\\": \" << \"\\\"\" << static_cast<void*>(v.get()) << \"\\\"\" << \", \";\n\n    if (v)\n        s << \"\\\"data\\\": \" << <#= streaming_for_type(containee, \"*v\") #>;\n    else\n        s << \"\\\"data\\\": \"\"\\\"<null>\\\"\";\n    s << \" }\";\n    return s;\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::variant_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "variant_helper_transform",
        "masd.wale.kvp.helper.family": "BoostVariant",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.io",
        "masd.physical.helpers.family": "BoostVariant",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.io.primitive_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.types.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.io",
        "masd.physical.helpers.owning_facets": "masd.cpp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/variant_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid variant_helper_transform::apply(std::ostream& os, const logical::entities::model& m,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto nt_qn(d.name_tree_qualified());\n        const auto n_qn(d.name_qualified());\n        auto snf(make_scoped_namespace_formatter(os, m, d.namespaces()));\n#>\n\nstruct <#= d.name_tree_identifiable() #>_visitor : public boost::static_visitor<> {\n    <#= d.name_tree_identifiable() #>_visitor(std::ostream& s) : stream_(s) {\n        s << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= d.name_qualified() #>\\\"\" << \", \";\n        s << \"\\\"data\\\": \";\n    }\n\n    ~<#= d.name_tree_identifiable() #>_visitor() { stream_ << \" }\"; }\n<#+\n        for (const auto& dd : hp.direct_descendants()) {\n#>\n\n    void operator()(const <#= dd.name_qualified() #><#= (dd.is_simple_type() ? \"\" : \"&\") #> v) const {\n<#+\n            if (dd.is_simple_type()) {\n#>\n        stream_ << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= dd.name_qualified() #>\\\"\" << \", \";\n        stream_ << \"\\\"value\\\": \";\n        stream_ << <#= streaming_for_type(dd, \"v\") #>;\n        stream_ << \" }\";\n<#+\n            } else\n#>\n        stream_ << <#= streaming_for_type(dd, \"v\") #>;\n    }\n<#+\n        }\n#>\n\nprivate:\n    std::ostream& stream_;\n};\n\ninline std::ostream& operator<<(std::ostream& s, const <#= d.name_tree_qualified() #>& v) {\n    boost::apply_visitor(<#= d.name_tree_identifiable() #>_visitor(s), v);\n    return s;\n}\n\n<#+\n    }\n#>\n\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::date_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "date_helper_transform",
        "masd.wale.kvp.helper.family": "BoostDate",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "BoostDate",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/date_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid date_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(const unsigned int position) {\n    const auto day(static_cast<unsigned short>(1 + (position % 27)));\n    boost::gregorian::date r(2002, 2, day);\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::bool_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "bool_helper_transform",
        "masd.wale.kvp.helper.family": "Boolean",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "Boolean",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/bool_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid bool_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& /*hp*/) const {\n#>\n\nbool create_bool(const unsigned int position) {\n    return (position % 2) != 0;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::char_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "char_helper_transform",
        "masd.wale.kvp.helper.family": "Character",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "Character",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/char_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid char_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #> create_<#= ident #>(const unsigned int position) {\n    const auto num(((position % 95) + 32) == 34 ? 35 : ((position % 95) + 32));\n    return static_cast<<#= qn #>>(num);\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::ptree_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "ptree_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPTree",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "BoostPTree",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/ptree_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid ptree_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(const unsigned int position) {\n    using boost::property_tree::ptree;\n    ptree c;\n    c.put(\"key_2\", position);\n    ptree r;\n    r.push_back(ptree::value_type(\"key_1\", c));\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::associative_container_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "associative_container_helper_transform",
        "masd.wale.kvp.helper.family": "AssociativeContainer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "AssociativeContainer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/associative_container_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid associative_container_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #> create_<#= ident #>(unsigned int position) {\n    <#= qn #> r;\n    for (unsigned int i(0); i < 4; ++i) {\n<#+\n    if (hp.direct_descendants().size() == 1) {\n        const auto containee(hp.direct_descendants().front());\n#>\n        r.insert(create_<#= containee.name_tree_identifiable() #>(position + i));\n<#+\n    } else if (hp.direct_descendants().size() == 2) {\n        const auto key(hp.direct_descendants().front());\n        const auto value(hp.direct_descendants().back());\n#>\n        r.insert(std::make_pair(create_<#= key.name_tree_identifiable() #>(position + i), create_<#= value.name_tree_identifiable() #>(position + i)));\n<#+\n    }\n#>\n    }\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::pair_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "pair_helper_transform",
        "masd.wale.kvp.helper.family": "Pair",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "Pair",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/pair_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid pair_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto first(hp.direct_descendants().front());\n    const auto second(hp.direct_descendants().back());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(unsigned int position) {\n    <#= qn #> r(\n        create_<#= first.name_tree_identifiable() #>(position),\n        create_<#= second.name_tree_identifiable() #>(position));\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::number_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "number_helper_transform",
        "masd.wale.kvp.helper.family": "Number",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "Number",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/number_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid number_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #> create_<#= ident #>(const unsigned int position) {\n    return static_cast<<#= qn #>>(position);\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::variant_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "variant_helper_transform",
        "masd.wale.kvp.helper.family": "BoostVariant",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "BoostVariant",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/variant_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid variant_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(unsigned int position) {\n    <#= qn #> r;\n\n<#+\n    unsigned int i(0);\n    const auto size(hp.direct_descendants().size());\n    for (const auto& dd : hp.direct_descendants()) {\n        if (i == 0)\n#>\n    if (position == 0 || ((position % <#= size #>) == 0))\n<#+\n        else if (i == 1)\n#>\n    else if (position == 1 || ((position % <#= size + 1 #>) == 0))\n<#+\n        else\n#>\n    else if ((position % <#= i #>) == 0)\n        r = create_<#= dd.name_tree_identifiable() #>(position);\n<#+\n        ++i;\n    }\n#>\n\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::path_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "path_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPath",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "BoostPath",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/path_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid path_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(const unsigned int position) {\n    std::ostringstream s;\n    s << \"/a/path/number_\" << position;\n    return <#= qn #>(s.str());\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::ptime_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "ptime_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPTime",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "BoostPTime",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/ptime_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid ptime_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(const unsigned int position) {\n    const auto day(static_cast<unsigned short>(1 + (position % 27)));\n    using boost::gregorian::date;\n    using boost::posix_time::ptime;\n    using boost::posix_time::time_duration;\n    date d(2002, 2, day);\n    ptime r(d, time_duration(1,2,3));\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::optional_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "optional_helper_transform",
        "masd.wale.kvp.helper.family": "Optional",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "Optional",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/optional_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid optional_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto containee(hp.direct_descendants().front());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(unsigned int position) {\n    <#= qn #> r(\n        create_<#= containee.name_tree_identifiable() #>(position));\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::smart_pointer_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "smart_pointer_helper_transform",
        "masd.wale.kvp.helper.family": "SmartPointer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "SmartPointer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/smart_pointer_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid smart_pointer_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto containee(hp.direct_descendants().front());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(unsigned int position) {\n    <#= qn #> r(\n        create_<#= containee.name_tree_identifiable() #>(position));\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::sequence_container_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "sequence_container_helper_transform",
        "masd.wale.kvp.helper.family": "SequenceContainer",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "SequenceContainer",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/sequence_container_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid sequence_container_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const auto containee(hp.direct_descendants().front());\n#>\n\n<#= qn #> create_<#= ident #>(unsigned int position) {\n    <#= qn #> r;\n    for (unsigned int i(0); i < 4; ++i) {\n        r.push_back(create_<#= containee.name_tree_identifiable() #>(position + i));\n    }\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::string_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "string_helper_transform",
        "masd.wale.kvp.helper.family": "String",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "String",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/string_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid string_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& /*hp*/) const {\n#>\n\nstd::string create_std_string(const unsigned int position) {\n    std::ostringstream s;\n    s << \"a_string_\" << position;\n    return s.str();\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::domain_type_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "domain_type_helper_transform",
        "masd.wale.kvp.helper.family": "Default",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "Default",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/domain_type_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid domain_type_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n    const bool is_pointer(d.is_pointer());\n    const bool is_recursive(d.is_circular_dependency());\n\n    if (is_recursive) {\n#>\n\n<#= qn #><#= (is_pointer ? \"*\" : \"\") #>\ncreate_<#= ident #>(const unsigned int) {\n<#+\n        if (is_pointer) {\n#>\n    return nullptr;\n<#+\n        } else {\n#>\n    return <#= qn #>();\n<#+\n        }\n#>\n}\n<#+\n    } else {\n#>\n\n<#= qn #><#= (is_pointer ? \"*\" : \"\") #>\ncreate_<#= ident #>(const unsigned int position) {\n    return <#= qn #>_generator::create<#= (is_pointer ? \"_ptr\" : \"\") #>(position);\n}\n<#+\n    }\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::time_duration_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "time_duration_helper_transform",
        "masd.wale.kvp.helper.family": "BoostTimeDuration",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.test_data",
        "masd.physical.helpers.family": "BoostTimeDuration",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.test_data.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/time_duration_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid time_duration_helper_transform::apply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n    const auto ident(d.name_tree_identifiable());\n#>\n\n<#= qn #>\ncreate_<#= ident #>(const unsigned int position) {\n    unsigned int hour(position % 55);\n    using boost::posix_time::time_duration;\n    time_duration r(hour, 2, 3);\n    return r;\n}\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::path_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "cpp_helper_transform_implementation_enabled",
        "masd.wale.kvp.class.simple_name": "path_helper_transform",
        "masd.wale.kvp.helper.family": "BoostPath",
        "masd.wale.kvp.facet.qualified_name": "masd.cpp.serialization",
        "masd.physical.helpers.family": "BoostPath",
        "masd.physical.helpers.owning_formatters": "masd.cpp.serialization.class_implementation",
        "masd.physical.helpers.owning_formatters": "masd.cpp.serialization.primitive_implementation",
        "masd.physical.helpers.owning_facets": "masd.cpp.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/path_helper_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid path_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    {\n        const auto d(hp.current());\n        const auto nt_qn(d.name_tree_qualified());\n#>\nnamespace boost {\nnamespace serialization {\n\ntemplate<class Archive>\nvoid serialize(Archive& ar, boost::filesystem::path& p, const unsigned int/*v*/)\n{\n    std::string s;\n    if(Archive::is_saving::value)\n        s = p.generic_string();\n    ar & boost::serialization::make_nvp(\"path\", s);\n    if(Archive::is_loading::value)\n        p = s;\n}\n\n} }\n<#+\n    }\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::types::floating_point_number_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "csharp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "floating_point_number_helper_transform",
        "masd.wale.kvp.helper.family": "FloatingPointNumber",
        "masd.wale.kvp.facet.qualified_name": "masd.csharp.types",
        "masd.physical.helpers.family": "FloatingPointNumber",
        "masd.physical.helpers.owning_formatters": "masd.csharp.types.class",
        "masd.physical.helpers.owning_formatters": "masd.csharp.types.primitive",
        "masd.physical.helpers.owning_facets": "masd.csharp.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/floating_point_number_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid floating_point_number_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n#>\n        /// <summary>\n        /// Compare floating point numbers, taking precision into account (<#= qn #> version).\n        /// </summary>\n        static private bool NearlyEqual(<#= qn #> lhs, <#= qn #> rhs)\n        {\n            <#= qn #> epsilon = Math.Max(Math.Abs(lhs), Math.Abs(rhs)) * <#= qn #>.Epsilon;\n            return Math.Abs(lhs - rhs) <= epsilon;\n        }\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::io::enumerable_helper",
      "stereotypes": [
        "masd::physical::helper"
      ],
      "tagged_values": {
        "masd.physical.wale_template_reference": "csharp_helper_transform_implementation",
        "masd.wale.kvp.class.simple_name": "enumerable_helper_transform",
        "masd.wale.kvp.helper.family": "Enumerable",
        "masd.wale.kvp.facet.qualified_name": "masd.csharp.io",
        "masd.physical.helpers.family": "Enumerable",
        "masd.physical.helpers.owning_formatters": "masd.io.types.class",
        "masd.physical.helpers.owning_formatters": "masd.io.types.primitive",
        "masd.physical.helpers.owning_facets": "masd.csharp.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=os #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/enumerable_helper_transform.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enumerable_helper_transform::\napply(std::ostream& os, const logical::entities::model& /*m*/,\n    const logical::entities::helper_properties& hp) const {\n    const auto d(hp.current());\n    const auto qn(d.name_tree_qualified());\n#>\n        /// <summary>\n        /// </summary>\n        static private bool NearlyEqual(<#= qn #> lhs, <#= qn #> rhs)\n        {\n            <#= qn #> epsilon = Math.Max(Math.Abs(lhs), Math.Abs(rhs)) * <#= qn #>.Epsilon;\n            return Math.Abs(lhs - rhs) <= epsilon;\n        }\n<#+\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::text_transform_repository",
      "stereotypes": [
        "dogen::typeable",
        "dogen::pretty_printable"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "model_to_text_transforms_by_meta_name",
          "type": "std::unordered_map<identification::entities::logical_meta_id, std::forward_list<std::shared_ptr<model_to_text_transform>>>"
        }
      ]
    },
    {
      "name": "transforms::text_transform_registrar",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "formatters::assistant",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::types::archetype_class_header_transform",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_header_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.constant_relation": "dogen.text.csharp.transforms.model_to_text_transform,archetype:masd.cpp.types.class_header,technical_space:csharp",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_header_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid archetype_class_header_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"types archetype class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple() + \"_transform\");\n#>\n\nclass <#= sn #> final : public text::transforms::model_to_text_transform {\npublic:\n    static const physical::entities::archetype& static_archetype();\n    const physical::entities::archetype& archetype() const override;\n\npublic:\nvoid apply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e,\n    physical::entities::artefact& a) const override;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::archetype_class_implementation_transform",
      "documentation": "Generates implementation files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_implementation_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_implementation_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid archetype_class_implementation_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& arch(ast.as<logical::entities::physical::archetype>(e));\n    ast.update_artefact();\n    a.content(arch.text_templating().rendered_stitch_template());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::archetype_class_header_factory",
      "documentation": "Generates header files for archetype factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_header_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.relation_status": "relatable",
        "masd.label.role": "type_declaration",
        "masd.physical.constant_relation": "dogen.physical.entities.archetype,archetype:masd.cpp.types.class_header",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_header_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid archetype_class_header_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"types archetype class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the archetype\n * <#= o.name().simple() #>.\n *\n * Archetype documentation: <#= o.documentation() #>\n */\nclass <#= o.name().simple() #>_factory final {\npublic:\n    /**\n     * @brief Makes the archetype.\n     */\n    static physical::entities::archetype make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::archetype_class_implementation_factory",
      "documentation": "Generates implementation files for archetype factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype",
        "masd.wale.kvp.archetype.simple_name": "archetype_class_implementation_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.constant_relation": "dogen.physical.helpers.meta_name_factory,archetype:masd.cpp.types.class_header",
        "masd.physical.variable_relation": "self,archetype:masd.cpp.types.archetype_class_header_factory",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_class_implementation_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid archetype_class_implementation_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& arch(ast.as<logical::entities::physical::archetype>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(arch));\n        {\n            const auto ns(ast.make_namespaces(arch.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(arch.name().simple() + \"_factory\");\n#>\n\nphysical::entities::archetype <#= sn #>::make() {\n    physical::entities::archetype r;\n    using pmnf = identification::helpers::physical_meta_name_factory;\n    r.meta_name(pmnf::make(\"<#= arch.backend_name() #>\", \"<#= arch.facet_name() #>\", \"<#= arch.name().simple() #>\"));\n    r.logical_meta_element_id(identification::entities::logical_meta_id(\"<#= arch.logical_meta_element_id().value() #>\"));\n    r.technical_space(identification::entities::technical_space::<#= arch.technical_space() #>);\n    r.relations().status(physical::entities::relation_status::<#= arch.relations().status() #>);\n<#+\n            if (!arch.postfix().empty())\n#>\n    r.postfix(\"<#= arch.postfix() #>\");\n<#+\n            for(const auto& l : arch.labels()) {\n#>\n    r.labels().push_back(identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n\n            for(const auto& cr : arch.relations().constant()) {\n#>\n\n    r.relations().constant().push_back(\n        physical::entities::constant_relation(\n            \"<#= cr.original_urn() #>\",\n            \"\"/*resolved_urn*/,\n<#+\n                if (cr.labels().empty()) {\n#>\n            std::list<identification::entities::label> {},\n<#+\n                } else {\n#>\n            std::list<identification::entities::label> {\n<#+\n                    utility::formatters::sequence_formatter sf(cr.labels().size());\n                    // sf.prefix_configuration().first(\": \").not_first(\"  \");\n                    sf.postfix_configuration().not_last(\",\")/*.last(\"\")*/;\n\n                    for(const auto& l : cr.labels()) {\n#>\n                identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\")<#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n#>\n            },\n<#+\n                }\n#>\n            \"<#= cr.logical_model_element_id() #>\"\n        )\n    );\n<#+\n            }\n\n            for(const auto& vr : arch.relations().variable()) {\n#>\n\n    r.relations().variable().push_back(\n        physical::entities::variable_relation(\n            \"<#= vr.original_urn() #>\",\n            \"\"/*resolved_urn*/,\n            physical::entities::variable_relation_type::<#= vr.type() #>\n        )\n    );\n<#+\n            }\n#>\n\n    return r;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::facet_class_header_transform",
      "documentation": "Generates header files for facet transforms.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.archetype.simple_name": "facet_class_header_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.constant_relation": "dogen.text.csharp.transforms.registrar,archetype:masd.cpp.types.class_header,technical_space:csharp",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_header_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid facet_class_header_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(e.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(fct.documentation());\n#>\nclass <#= fct.name().simple() #>_facet_chain final {\npublic:\n    static const physical::entities::facet& static_facet();\n    const physical::entities::facet& facet() const;\n\npublic:\n    // static void initialise(registrar& r);\n};\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::facet_class_implementation_transform",
      "documentation": "Generates implementation files for facet transforms.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.archetype.simple_name": "facet_class_implementation_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.variable_relation": "transparent,role:type_declaration",
        "masd.physical.constant_relation": "dogen.text.transforms.transformation_error,archetype:masd.cpp.types.class_header",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/entities/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_implementation_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid facet_class_implementation_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(fct.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(fct.name().simple() + \"_facet_chain\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= fct.name().qualified().dot() #>\"));\n\nphysical::entities::facet make_facet() {\n    identification::helpers::physical_meta_name_builder b;\n    b.meta_model(\"<#= fct.meta_model_name() #>\");\n    b.backend(\"<#= fct.backend_name() #>\");\n    b.facet(\"<#= fct.name().simple() #>\");\n\n    physical::entities::facet r;\n    r.meta_name(b.build());\n    return r;\n}\n\n}\n\nconst physical::entities::facet& <#= sn #>::static_facet() {\n    static const auto r(make_facet());\n    return r;\n}\n\nconst physical::entities::facet& <#= sn #>::facet() const {\n    return static_facet();\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::facet_class_header_factory",
      "documentation": "Generates header files for facet factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.archetype.simple_name": "facet_class_header_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.role": "type_declaration",
        "masd.physical.relation_status": "relatable",
        "masd.physical.constant_relation": "dogen.physical.entities.facet,archetype:masd.cpp.types.class_header",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_header_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid facet_class_header_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(e.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the facet\n * <#= fct.name().simple() #>.\n *\n * Facet documentation: <#= fct.documentation() #>\n */\nclass <#= fct.name().simple() #>_factory final {\npublic:\n    static physical::entities::facet make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::facet_class_implementation_factory",
      "documentation": "Generates implementation files for facet factory.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_facet",
        "masd.wale.kvp.archetype.simple_name": "facet_class_implementation_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.variable_relation": "transparent,archetype:masd.cpp.types.archetype_class_header_factory",
        "masd.physical.constant_relation": "dogen.physical.helpers.meta_name_builder,archetype:masd.cpp.types.class_header",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/types/entities/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/facet.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/facet_class_implementation_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid facet_class_implementation_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"facet class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& fct(ast.as<logical::entities::physical::facet>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(fct));\n        {\n            const auto ns(ast.make_namespaces(fct.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(fct.name().simple() + \"_factory\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= fct.name().qualified().dot() #>\"));\n\n}\n\nphysical::entities::facet <#= sn #>::make() {\n    identification::helpers::physical_meta_name_builder b;\n    b.meta_model(\"<#= fct.meta_model_name() #>\");\n    b.backend(\"<#= fct.backend_name() #>\");\n    b.facet(\"<#= fct.name().simple() #>\");\n\n    physical::entities::facet r;\n    r.meta_name(b.build());\n<#+\n            if (!fct.directory_name().empty())\n#>\n    r.directory_name(\"<#= fct.directory_name() #>\");\n<#+\n            if (!fct.postfix().empty())\n#>\n    r.postfix(\"<#= fct.postfix() #>\");\n<#+\n            for(const auto& l : fct.labels()) {\n#>\n    r.labels().push_back(identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n\n            if (!fct.archetypes().empty() || !fct.helpers().empty()) {\n#>\n\n    const auto lambda([&](auto& container, const auto& element) {\n        const auto id(element.meta_name().id());\n        const auto pair(std::make_pair(id, element));\n        const auto inserted(container.insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_archetype(\"Duplicate id: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_archetype << id;\n            BOOST_THROW_EXCEPTION(\n                transformation_error(duplicate_archetype + id.value()));\n        }\n    });\n\n<#+\n            }\n\n            for (const auto& n : fct.archetypes()) {\n#>\n    lambda(r.archetypes(), <#= n.simple() #>_factory::make());\n<#+\n            }\n#>\n\n<#+\n            for (const auto& n : fct.helpers()) {\n#>\n    lambda(r.helpers(), <#= n.simple() #>_factory::make());\n<#+\n            }\n\n#>\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::backend_class_header_transform",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.archetype.simple_name": "backend_class_header_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_header_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid backend_class_header_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(be.documentation());\n#>\nclass <#= be.name().simple() #>_backend_chain final {\npublic:\n    // static const physical::entities::backend& static_backend();\n    // const physical::entities::backend& backend() const;\n\npublic:\n    // static void initialise(transforms::registrar& r);\n};\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::backend_class_implementation_transform",
      "documentation": "Generates implementation files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.archetype.simple_name": "backend_class_implementation_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_implementation_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid backend_class_implementation_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(be.name().simple() + \"_backend_chain\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= be.name().qualified().dot() #>\"));\n\n/*\nphysical::entities::backend make_backend() {\n    identification::helpers::physical_meta_name_builder b;\n    b.meta_model(\"<#= be.meta_model_name() #>\");\n    b.backend(\"<#= be.backend_name() #>\");\n\n    physical::entities::backend r;\n    r.meta_name(b.build());\n\n    const auto lambda([&](const auto& fct) {\n        const auto id(fct.meta_name().id());\n        const auto pair(std::make_pair(id, fct));\n        const auto inserted(r.facets().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_facet(\"Duplicate facet: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id.value()));\n        }\n    });\n\n<#+\n            for (const auto& n : be.facets()) {\n#>\n    lambda(<#= n.simple() #>::<#= n.simple() #>_facet_chain::static_facet());\n<#+\n            }\n#>\n    return r;\n}\n*/\n\n}\n/*\nconst physical::entities::backend& <#= sn #>::static_backend() {\n    static const auto r(make_backend());\n    return r;\n}\n\nconst physical::entities::backend& <#= sn #>::backend() const {\n    return static_backend();\n}\n*/\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::backend_class_header_factory",
      "documentation": "Generates header files for backend factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.archetype.simple_name": "backend_class_header_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.relation_status": "relatable",
        "masd.label.role": "type_declaration",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_header_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid backend_class_header_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the backend\n * <#= be.name().simple() #>.\n *\n * Backend documentation: <#= be.documentation() #>\n */\nclass <#= be.name().simple() #>_factory final {\npublic:\n    static physical::entities::backend make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::part_class_header_transform",
      "documentation": "Generates header files for parts.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_part",
        "masd.wale.kvp.archetype.simple_name": "part_class_header_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/part.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_header_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid part_class_header_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"part class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::physical::part>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #> final : public model_to_text_transform {\npublic:\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::part_class_header_factory",
      "documentation": "Generates header files for part factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_part",
        "masd.wale.kvp.archetype.simple_name": "part_class_header_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.relation_status": "relatable",
        "masd.label.role": "type_declaration",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/part.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_header_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid part_class_header_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"part class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& part(ast.as<logical::entities::physical::part>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(part));\n        {\n            const auto ns(ast.make_namespaces(part.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the part\n * <#= part.name().simple() #>.\n *\n * Part documentation: <#= part.documentation() #>\n */\n class <#= part.name().simple() #>_factory final {\npublic:\n    static physical::entities::part make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::helper_class_header_transform",
      "documentation": "Generates header files for helpers.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_helper",
        "masd.wale.kvp.archetype.simple_name": "helper_class_header_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_header_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_header_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid helper_class_header_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"types helper class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::physical::helper>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple() + \"_transform\");\n#>\n\nclass <#= sn #> final : public text::transforms::helper_transform {\npublic:\n    std::string id() const override;\n    std::string family() const override;\n    std::list<std::string> owning_formatters() const override;\n    std::list<std::string> owning_facets() const override;\n    std::string helper_name() const override;\n    bool is_enabled(const physical::entities::model& m,\n        const logical::entities::element& e,\n        const physical::entities::artefact& a,\n        const logical::entities::helper_properties& hp) const override;\n    void apply(std::ostream& os,\n        const logical::entities::model& m,\n        const logical::entities::helper_properties& hp) const override;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::helper_class_header_factory",
      "documentation": "Generates header files for helper factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_helper",
        "masd.wale.kvp.archetype.simple_name": "helper_class_header_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.relation_status": "relatable",
        "masd.label.role": "type_declaration",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_header_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid helper_class_header_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"types helper class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::physical::helper>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the helper\n * <#= o.name().simple() #>.\n *\n * Helper documentation: <#= o.documentation() #>\n */\nclass <#= o.name().simple() #>_factory final {\npublic:\n    /**\n     * @brief Makes the helper.\n     */\n    static physical::entities::helper make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::archetype_kind_class_header_factory",
      "documentation": "Generates header files for archetype_kind factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype_kind",
        "masd.wale.kvp.archetype.simple_name": "archetype_kind_class_header_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.relation_status": "relatable",
        "masd.label.role": "type_declaration",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype_kind.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_kind_class_header_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_kind_class_header_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid archetype_kind_class_header_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype_kind class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& be(ast.as<logical::entities::physical::archetype_kind>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Creates a physical representation for the archetype_kind\n * <#= be.name().simple() #>.\n *\n * Archetype_Kind documentation: <#= be.documentation() #>\n */\nclass <#= be.name().simple() #>_factory final {\npublic:\n    static physical::entities::archetype_kind make();\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::backend_class_implementation_factory",
      "documentation": "Generates implementation files for backend factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_backend",
        "masd.wale.kvp.archetype.simple_name": "backend_class_implementation_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/backend.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/backend_class_implementation_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid backend_class_implementation_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"backend class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& be(ast.as<logical::entities::physical::backend>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(be));\n        {\n            const auto ns(ast.make_namespaces(be.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(be.name().simple() + \"_factory\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= be.name().qualified().dot() #>\"));\n\n}\n\nphysical::entities::backend <#= sn #>::make() {\n    identification::helpers::physical_meta_name_builder b;\n    b.meta_model(\"<#= be.meta_model_name() #>\");\n    b.backend(\"<#= be.backend_name() #>\");\n\n    physical::entities::backend r;\n    r.meta_name(b.build());\n<#+\n            if (!be.directory_name().empty())\n#>\n    r.directory_name(\"<#= be.directory_name() #>\");\n<#+\n            for(const auto& l : be.labels()) {\n#>\n    r.labels().push_back(identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n\n            if (!be.facets().empty()) {\n#>\n\n    const auto fct_inserter([&](const auto& fct) {\n        const auto id(fct.meta_name().id());\n        const auto pair(std::make_pair(id, fct));\n        const auto inserted(r.facets().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_facet(\"Duplicate facet: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id.value()));\n        }\n    });\n\n<#+\n                for (const auto& n : be.facets()) {\n                    // Bit of a hack: facets work as namespaces.\n#>\n    fct_inserter(<#= n.simple() #>::<#= n.simple() #>_factory::make());\n<#+\n                }\n            }\n\n            if (!be.archetype_kinds().empty()) {\n#>\n\n    const auto ak_inserter([&](const auto& ak) {\n        const auto pair(std::make_pair(ak.id(), ak));\n        const auto inserted(r.archetype_kinds().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_facet(\"Duplicate archetype kind: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_facet << ak.id();\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + ak.id()));\n        }\n    });\n<#+\n                for (const auto& n : be.archetype_kinds()) {\n#>\n    ak_inserter(<#= n.simple() #>_factory::make());\n<#+\n                }\n            }\n\n            if (!be.parts().empty()) {\n#>\n\n    const auto part_inserter([&](const auto& part) {\n        const auto id(part.meta_name().id());\n        const auto pair(std::make_pair(id, part));\n        const auto inserted(r.parts().insert(pair).second);\n        if (!inserted) {\n            using text::transforms::transformation_error;\n            const std::string duplicate_facet(\"Duplicate part: \");\n            BOOST_LOG_SEV(lg, error) << duplicate_facet << id;\n            BOOST_THROW_EXCEPTION(transformation_error(duplicate_facet + id.value()));\n        }\n    });\n<#+\n                for (const auto& n : be.parts()) {\n#>\n    part_inserter(<#= n.simple() #>_factory::make());\n<#+\n                }\n            }\n#>\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::part_class_implementation_transform",
      "documentation": "Generates implementation files for parts.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_part",
        "masd.wale.kvp.archetype.simple_name": "part_class_implementation_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/part.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_implementation_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid part_class_implementation_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"part class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::part_class_implementation_factory",
      "documentation": "Generates implementation files for part factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_part",
        "masd.wale.kvp.archetype.simple_name": "part_class_implementation_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/part.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/part_class_implementation_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid part_class_implementation_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"part class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& part(ast.as<logical::entities::physical::part>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(part));\n        {\n            const auto ns(ast.make_namespaces(part.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(part.name().simple() + \"_factory\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= part.name().qualified().dot() #>\"));\n\n}\n\nphysical::entities::part <#= sn #>::make() {\n    identification::helpers::physical_meta_name_builder b;\n    b.meta_model(\"<#= part.meta_model_name() #>\");\n    b.backend(\"<#= part.backend_name() #>\");\n    b.part(\"<#= part.name().simple() #>\");\n\n    physical::entities::part r;\n    r.meta_name(b.build());\n<#+\n             if (!part.directory_name().empty())\n#>\n    r.directory_name(\"<#= part.directory_name() #>\");\n<#+\n             for(const auto& l : part.labels()) {\n#>\n    r.labels().push_back(identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n#>\n\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::helper_class_implementation_transform",
      "documentation": "Generates implementation files for helpers.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_helper",
        "masd.wale.kvp.archetype.simple_name": "helper_class_implementation_transform",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "transform"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_implementation_transform_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_implementation_transform_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid helper_class_implementation_transform_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"helper class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& arch(ast.as<logical::entities::physical::helper>(e));\n    ast.update_artefact();\n    a.content(arch.text_templating().rendered_stitch_template());\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::helper_class_implementation_factory",
      "documentation": "Generates implementation files for helper factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_helper",
        "masd.wale.kvp.archetype.simple_name": "helper_class_implementation_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/helper_class_implementation_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid helper_class_implementation_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"helper class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& hlp(ast.as<logical::entities::physical::helper>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(hlp));\n        {\n            const auto ns(ast.make_namespaces(hlp.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(hlp.name().simple() + \"_factory\");\n#>\n\nphysical::entities::helper <#= sn #>::make() {\n    physical::entities::helper r;\n    using pmnf = identification::helpers::physical_meta_name_factory;\n    r.meta_name(pmnf::make(\"<#= hlp.backend_name() #>\", \"<#= hlp.facet_name() #>\", \"<#= hlp.name().simple() #>\"));\n    // r.relations().status(physical::entities::relation_status::<#= hlp.relations().status() #>);\n<#+\n             if (!hlp.family().empty()) {\n#>\n    r.family(\"<#= hlp.family() #>\");\n<#+\n             }\n\n             if (!hlp.owning_formatters().empty() || !hlp.owning_facets().empty()) {\n#>\n    using identification::entities::physical_meta_id;\n<#+\n             }\n\n             for (const auto& of : hlp.owning_formatters()) {\n#>\n    r.owning_formatters().push_back(\n        physical_meta_id(\"<#= of #>\"));\n<#+\n             }\n\n\n\n             for (const auto& of : hlp.owning_facets()) {\n#>\n    r.owning_facets().push_back(\n        physical_meta_id(\"<#= of #>\"));\n<#+\n             }\n\n             for(const auto& l : hlp.labels()) {\n#>\n    r.labels().push_back(identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\"));\n<#+\n            }\n\n            for(const auto& cr : hlp.relations().constant()) {\n#>\n\n    r.relations().constant().push_back(\n        physical::entities::constant_relation(\n            \"<#= cr.original_urn() #>\",\n            \"\"/*resolved_urn*/,\n<#+\n                if (cr.labels().empty()) {\n#>\n            std::list<identification::entities::label> {},\n<#+\n                } else {\n#>\n            std::list<identification::entities::label> {\n<#+\n                    utility::formatters::sequence_formatter sf(cr.labels().size());\n                    // sf.prefix_configuration().first(\": \").not_first(\"  \");\n                    sf.postfix_configuration().not_last(\",\")/*.last(\"\")*/;\n\n                    for(const auto& l : cr.labels()) {\n#>\n                identification::entities::label(\"<#= l.key() #>\", \"<#= l.value() #>\")<#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n#>\n            },\n<#+\n                }\n#>\n            \"<#= cr.logical_model_element_id() #>\"\n        )\n    );\n<#+\n            }\n\n            for(const auto& vr : hlp.relations().variable()) {\n#>\n\n    r.relations().variable().push_back(\n        physical::entities::variable_relation(\n            \"<#= vr.original_urn() #>\",\n            \"\"/*resolved_urn*/,\n            physical::entities::variable_relation_type::<#= vr.type() #>\n        )\n    );\n<#+\n            }\n#>\n\n    return r;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::archetype_kind_class_implementation_factory",
      "documentation": "Generates implementation files for archetype_kind factories.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.physical_archetype_kind",
        "masd.wale.kvp.archetype.simple_name": "archetype_kind_class_implementation_factory",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.physical.postfix": "factory"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/physical/archetype_kind.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_kind_class_implementation_factory_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/archetype_kind_class_implementation_factory_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid archetype_kind_class_implementation_factory_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"archetype_kind class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ak(ast.as<logical::entities::physical::archetype_kind>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(ak));\n        {\n            const auto ns(ast.make_namespaces(ak.name(),\n                    false/*detect_model_name*/));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(ak.name().simple() + \"_factory\");\n#>\nnamespace {\n\nusing namespace dogen::utility::log;\nstatic logger lg(logger_factory(\"<#= ak.name().qualified().dot() #>\"));\n\n}\n\nphysical::entities::archetype_kind <#= sn #>::make() {\n    physical::entities::archetype_kind r;\n    r.id(\"<#= ak.name().simple() #>\");\n    r.file_extension(\"<#= ak.file_extension() #>\");\n    return r;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.role": "type_declaration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(o.documentation());\n            if (o.parents().empty()) {\n#>\nclass <#= sn #> <#= ast.make_final_keyword_text(o) #>{\n<#+\n            } else {\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\nclass <#= sn #> <#= ast.make_final_keyword_text(o) #>: public <#= pqn #> {\n<#+\n            }\n\n            /*\n             * Compiler generated constructors and destructors.\n             */\n            if (ast.supports_defaulted_functions()) {\n#>\npublic:\n<#+\n                if (!ast.requires_manual_default_constructor())\n#>\n    <#= sn #>() = default;\n    <#= sn #>(const <#= sn #>&) = default;\n<#+\n                if (!ast.requires_manual_move_constructor())\n#>\n    <#= sn #>(<#= sn #>&&) = default;\n<#+\n                if (!o.in_inheritance_relationship())\n#>\n    ~<#= sn #>() = default;\n<#+\n                if (o.is_immutable())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = delete;\n<#+\n                else if (o.all_attributes().empty())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = default;\n\n<#+\n            }\n\n            /*\n             * Manually generated default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\npublic:\n    <#= sn #>();\n\n<#+\n            }\n\n            /*\n             * Manually generated destructor.\n             *\n             * according to MEC++, item 33, base classes should always be\n             * abstract. this avoids all sorts of tricky problems with\n             * assignment and swap.\n             *\n             * incidentally, this also fixes some strange clang errors:\n             * undefined reference to `vtable.\n             */\n            if (o.is_parent()) {\n#>\n    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> = 0;\n\n<#+\n            } else if (o.is_child() != 0) {\n#>\n    virtual ~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n            }\n\n            /*\n             * Manually generated move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\npublic:\n    <#= sn #>(<#= sn #>&& rhs);\n\n<#+\n            }\n\n            /*\n             * Manually generated complete constructor.\n             */\n            if (!o.all_attributes().empty()) {\n#>\npublic:\n<#+\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                    const auto attr(*o.all_attributes().begin());\n#>\n    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);\n<#+\n                } else {\n#>\n    <#= sn #>(\n<#+\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\");\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n        const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n#>\n\n<#+\n            }\n\n            /*\n             * Serialisaton Friends\n             */\n            if (ast.is_serialization_enabled()) {\n#>\nprivate:\n    template<typename Archive>\n    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\n    template<typename Archive>\n    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n<#+\n            }\n\n            /*\n             * Visitation.\n             */\n            if (o.is_visitation_root()) {\n                const auto vsn(o.base_visitor()->simple());\n#>\npublic:\n    virtual void accept(const <#= vsn #>& v) const = 0;\n    virtual void accept(<#= vsn #>& v) const = 0;\n    virtual void accept(const <#= vsn #>& v) = 0;\n    virtual void accept(<#= vsn #>& v) = 0;\n\n<#+\n            } else if (o.is_visitation_leaf()) {\n                std::string bvn;\n                std::string rpn;\n                if (o.derived_visitor()) {\n                    bvn = ast.get_qualified_name(*o.base_visitor());\n                    rpn = ast.get_qualified_name(o.root_parents().front());\n                } else {\n                    bvn = o.base_visitor()->simple();\n                    rpn = o.root_parents().front().simple();\n                }\n#>\npublic:\n    using <#= rpn #>::accept;\n\n    virtual void accept(const <#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;\n    virtual void accept(<#= bvn #>& v) const<#= ast.make_override_keyword_text() #>;\n    virtual void accept(const <#= bvn #>& v)<#= ast.make_override_keyword_text() #>;\n    virtual void accept(<#= bvn #>& v)<#= ast.make_override_keyword_text() #>;\n<#+\n            }\n\n            /*\n             * Streaming\n             */\n            if (ast.is_io_enabled()) {\n                if (o.is_parent()) {\n#>\npublic:\n    virtual void to_stream(std::ostream& s) const;\n\n<#+\n                } else if (!o.parents().empty()) {\n#>\npublic:\n    void to_stream(std::ostream& s) const<#= ast.make_override_keyword_text() #>;\n\n<#+\n                }\n            }\n\n            /*\n             * Getters and setters.\n             */\n            if (!o.local_attributes().empty()) {\n#>\npublic:\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());\n\n                    if (attr.parsed_type().is_current_simple_type()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;\n<#+\n                        if (attr.is_immutable()) {\n#>\n\n<#+\n                            continue;\n                        }\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                    } else {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;\n<#+\n                        if (attr.is_immutable()) {\n#>\n\n<#+\n                            continue;\n                        }\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                        if (ast.supports_move_operator()) {\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);\n<#+\n                        }\n                    }\n                    ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());\n#>\n\n<#+\n                }\n            }\n\n            /*\n             * Equality.\n             *\n             * Equality is only public in leaf classes - MEC++-33.\n             */\n            if (o.is_parent()) {\n#>\nprotected:\n    bool compare(const <#= sn #>& rhs) const;\n<#+\n            } else {\n#>\npublic:\n    bool operator==(const <#= sn #>& rhs) const;\n    bool operator!=(const <#= sn #>& rhs) const {\n        return !this->operator==(rhs);\n    }\n\n<#+\n            }\n\n            if (o.in_inheritance_relationship()) {\n#>\npublic:\n<#+\n                if (o.is_parent() && !o.is_child()) {\n#>\n    virtual bool equals(const <#= sn #>& other) const = 0;\n<#+\n                } else if (o.is_parent()) {\n                    const auto rpn(o.root_parents().front());\n#>\n    virtual bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const = 0;\n<#+\n                } else if (!o.root_parents().empty()) {\n                    const auto rpn(o.root_parents().front());\n#>\n    bool equals(const <#= ast.get_qualified_name(rpn) #>& other) const<#= ast.make_override_keyword_text() #>;\n<#+\n                }\n#>\n\n<#+\n             }\n\n            /*\n             * Swap and assignment.\n             *\n             * Swap and assignment are only public in leaf classes - MEC++-33\n             */\n            if ((!o.all_attributes().empty() || o.is_parent()) && !o.is_immutable()) {\n                if (o.is_parent()) {\n#>\nprotected:\n<#+\n                } else {\n#>\npublic:\n<#+\n                }\n#>\n    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;\n<#+\n                if (!o.is_parent() && !o.is_immutable()) {\n#>\n    <#= sn #>& operator=(<#= sn #> other);\n<#+\n                }\n#>\n\n<#+\n            }\n\n            /*\n             * Member variables.\n             */\n            if (!o.local_attributes().empty()) {\n#>\nprivate:\n<#+\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;\n<#+\n                }\n            }\n#>\n};\n\n<#+\n            /*\n             * Destructor implementation.\n             */\n            if (o.is_parent()) {\n#>\ninline <#= sn #>::~<#= sn #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n            }\n\n            /*\n             * Global equality operator implementation.\n             */\n            if (o.is_parent()) {\n#>\ninline bool operator==(const <#= sn #>& lhs, const <#= sn #>& rhs) {\n    return lhs.equals(rhs);\n}\n\n<#+\n            }\n        }\n\n        if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {\n#>\n\nnamespace std {\n\ntemplate<>\ninline void swap(\n    <#= qn #>& lhs,\n    <#= qn #>& rhs) {\n    lhs.swap(rhs);\n}\n\n}\n<#+\n        }\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::class_forward_declarations",
      "documentation": "Generates forward declarations for classes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.archetype.simple_name": "class_forward_declarations",
        "masd.physical.relation_status": "relatable",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "forward declaration",
        "masd.physical.postfix": "fwd"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/class_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/class_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_forward_declarations_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class forward declarations\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::namespace_header",
      "documentation": "Generates header files for namespaces.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.module",
        "masd.wale.kvp.archetype.simple_name": "namespace_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/module.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/namespace_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/namespace_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid namespace_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"namespace header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& m(ast.as<logical::entities::structural::module>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            if (ast.requires_nested_namespaces()) {\n                ast.comment(m.documentation());\n                const auto ns(ast.make_namespaces(e.name(),\n                        false/*detect_model_name*/));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n            } else {\n                const auto ns(ast.make_namespaces(m.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n                ast.comment(m.documentation());\n#>\nnamespace <#= m.name().simple() #> {\n}\n\n<#+\n            }\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::visitor_header",
      "documentation": "Generates header files for visitors.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visitor",
        "masd.wale.kvp.archetype.simple_name": "visitor_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "type_declaration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/visitor.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/visitor_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/visitor_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid visitor_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"visitor header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& v(ast.as<logical::entities::structural::visitor>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(v.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(v.documentation());\n            if (!v.parent())\n#>\nclass <#= v.name().simple() #> {\n<#+\n            else {\n                const auto& pn(*v.parent());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\nclass <#= v.name().simple() #> : public <#= pqn #> {\n<#+\n            }\n#>\npublic:\n    virtual ~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = 0;\n\npublic:\n<#+\n            if (v.parent()) {\n                const auto& pn(*v.parent());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    using <#= pqn #>::visit;\n\n<#+\n            }\n\n            bool is_first(true);\n            for (const auto& t : v.visits()) {\n                if (!is_first)\n#>\n\n<#+\n                const auto qn(ast.get_qualified_name(t));\n                const auto doc(\"Accept visits for type \" + qn);\n                ast.comment_start_method_group(doc);\n#>\n    virtual void visit(const <#= qn #>&) const { }\n    virtual void visit(const <#= qn #>&) { }\n    virtual void visit(<#= qn #>&) const { }\n    virtual void visit(<#= qn #>&) { }\n<#+\n                ast.comment_end_method_group(doc);\n                is_first = false;\n            }\n#>\n};\n\ninline <#= v.name().simple() #>::~<#= v.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> { }\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "type_declaration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto attr(p.value_attribute());\n\n            ast.comment(p.documentation());\n#>\nclass <#= sn #> final {\npublic:\n<#+\n            /*\n             * Compiler generated constructors and destructors.\n             */\n            if (!ast.requires_manual_default_constructor())\n#>\n    <#= sn #>() = default;\n    <#= sn #>(const <#= sn #>&) = default;\n<#+\n            if (!ast.requires_manual_move_constructor())\n#>\n    <#= sn #>(<#= sn #>&&) = default;\n    ~<#= sn #>() = default;\n<#+\n            if (p.is_immutable())\n#>\n    <#= sn #>& operator=(const <#= sn #>&) = delete;\n<#+\n            /*\n             * Manually generated default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\npublic:\n    <#= sn #>();\n\n<#+\n            }\n\n            /*\n             * Manually generated move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\npublic:\n    <#= sn #>(<#= sn #>&& rhs);\n\n<#+\n            }\n\n            /*\n             * Manually generated complete constructor.\n             */\n#>\npublic:\n    explicit <#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>);\n\n<#+\n            /*\n             * Serialisaton Friends\n             */\n            if (ast.is_serialization_enabled()) {\n#>\nprivate:\n    template<typename Archive>\n    friend void boost::serialization::save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\n    template<typename Archive>\n    friend void boost::serialization::load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n<#+\n            }\n\n            /*\n             * Getters and setters.\n             */\n#>\npublic:\n<#+\n            ast.comment_start_method_group(attr.documentation(), !attr.is_immutable());\n            if (attr.parsed_type().is_current_simple_type()) {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #>() const;\n<#+\n                if (attr.is_immutable()) {\n#>\n\n<#+\n\n                } else {\n#>\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n<#+\n                }\n            } else {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= attr.name().simple() #>() const;\n<#+\n                if (attr.is_immutable()) {\n#>\n\n<#+\n                } else {\n#>\n    <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>();\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> v);\n    <#= ast.make_setter_return_type(sn, attr) #> <#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v);\n<#+\n                }\n            }\n            ast.comment_end_method_group(attr.documentation(), !attr.is_immutable());\n\n            /*\n             * Explicit cast.\n             */\n#>\n\npublic:\n    explicit operator <#= ast.get_qualified_name(attr.parsed_type()) #>() const {\n        return <#= attr.member_variable_name() #>;\n    }\n<#+\n            /*\n             * Equality.\n             */\n#>\n\npublic:\n    bool operator==(const <#= sn #>& rhs) const;\n    bool operator!=(const <#= sn #>& rhs) const {\n        return !this->operator==(rhs);\n    }\n\n<#+\n            /*\n             * Swap and assignment.\n             */\n#>\npublic:\n    void swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #>;\n<#+\n            if (!p.is_immutable()) {\n#>\n    <#= sn #>& operator=(<#= sn #> other);\n<#+\n            }\n\n            /*\n             * Member variables.\n             */\n#>\n\nprivate:\n    <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.member_variable_name() #>;\n};\n\n<#+\n        } // snf\n\n        if (!p.is_immutable()) {\n#>\n\nnamespace std {\n\ntemplate<>\ninline void swap(\n    <#= qn #>& lhs,\n    <#= qn #>& rhs) {\n    lhs.swap(rhs);\n}\n\n}\n<#+\n        }\n#>\n\n<#+\n    } //ah  sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::primitive_forward_declarations",
      "documentation": "Generates forward declarations for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.kvp.archetype.simple_name": "primitive_forward_declarations",
        "masd.physical.relation_status": "relatable",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "forward declaration",
        "masd.physical.postfix": "fwd"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/primitive_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/primitive_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_forward_declarations_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive forward declarations\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(p));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= p.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::feature_template_bundle_header",
      "documentation": "Generates implementation files for feature template bundles\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_template_bundle",
        "masd.wale.kvp.archetype.simple_name": "feature_template_bundle_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_template_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_template_bundle_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_template_bundle_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid feature_template_bundle_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature template bundle header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& fb(ast.as<logical::entities::variability::feature_template_bundle>(e));\n\n    {\n        const auto sn(fb.name().simple());\n        const auto qn(ast.get_qualified_name(fb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(fb));\n        ast.add_helper_methods(fb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(fb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using utility::string::splitter;\n#>\n\n<#+\n            ast.comment(fb.documentation());\n#>\nclass <#= sn #> final {\n<#+\n            if (fb.generate_static_configuration()) {\n#>\npublic:\n    struct feature_group {\n<#+\n                for (const auto& fb_ft : fb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        variability::entities::feature <#= simple_key #>;\n<#+\n                }\n#>\n    };\n\n    static feature_group\n    make_feature_group(const variability::entities::feature_model& fm);\n\npublic:\n    struct static_configuration {\n<#+\n                for (const auto& fb_ft : fb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;\n<#+\n                }\n\n                if (fb.requires_manual_default_constructor()) {\n                    bool is_first(true);\n                    std::ostringstream ss;\n                    for (const auto& fb_ft : fb.feature_templates()) {\n                        if (!fb_ft.parsed_type().is_current_simple_type())\n                            continue;\n\n                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n\n                        if (!is_first)\n                            ss << \",\" << std::endl << \"            \";\n\n                        ss << simple_key << \"()\";\n                        is_first = false;\n                    }\n#>\n\n        static_configuration() :\n            <#= ss.str() #> {}\n<#+\n                }\n#>\n    };\n\n    static static_configuration make_static_configuration(\n        const feature_group& fg,\n        const variability::entities::configuration& cfg);\n\n    template<typename Configurable>\n    static static_configuration make_static_configuration(\n        const feature_group& fg, const Configurable& c) {\n        return make_static_configuration(fg, *c.configuration());\n    }\n<#+\n            }\n\n            if (fb.generate_registration()) {\n#>\n\npublic:\n    static std::list<dogen::variability::entities::feature_template>\n    make_templates();\n<#+\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::feature_bundle_header",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_bundle",
        "masd.wale.kvp.archetype.simple_name": "feature_bundle_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_bundle_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_bundle_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid feature_bundle_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature bundle header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));\n\n    {\n        const auto sn(fb.name().simple());\n        const auto qn(ast.get_qualified_name(fb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(fb));\n        ast.add_helper_methods(fb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(fb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using utility::string::splitter;\n#>\n\n<#+\n            ast.comment(fb.documentation());\n#>\nclass <#= sn #> final {\n<#+\n            if (fb.generate_static_configuration()) {\n#>\npublic:\n    struct feature_group {\n<#+\n                for (const auto& fb_ft : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        variability::entities::feature <#= simple_key #>;\n<#+\n                }\n#>\n    };\n\n    static feature_group\n    make_feature_group(const variability::entities::feature_model& fm);\n\npublic:\n    struct static_configuration {\n<#+\n                for (const auto& fb_ft : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n#>\n        <#= ast.get_qualified_name(fb_ft.parsed_type()) #> <#= simple_key #>;\n<#+\n                }\n\n                if (fb.requires_manual_default_constructor()) {\n                    bool is_first(true);\n                    std::ostringstream ss;\n                    for (const auto& fb_ft : fb.features()) {\n                        if (!fb_ft.parsed_type().is_current_simple_type())\n                            continue;\n\n                        const auto simple_key(splitter::split_scoped(fb_ft.key()).back());\n\n                        if (!is_first)\n                            ss << \",\" << std::endl << \"            \";\n\n                        ss << simple_key << \"()\";\n                        is_first = false;\n                    }\n#>\n\n        static_configuration() :\n            <#= ss.str() #> {}\n<#+\n                }\n#>\n    };\n\n    static static_configuration make_static_configuration(\n        const feature_group& fg,\n        const variability::entities::configuration& cfg);\n\n    template<typename Configurable>\n    static static_configuration make_static_configuration(\n        const feature_group& fg, const Configurable& c) {\n        return make_static_configuration(fg, *c.configuration());\n    }\n<#+\n            }\n#>\n\n<#+\n            if (fb.generate_registration()) {\n#>\npublic:\n    static std::list<dogen::variability::entities::feature>\n    make_features();\n<#+\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::variability_initializer_header",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_initializer",
        "masd.wale.kvp.archetype.simple_name": "variability_initializer_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/initializer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/variability_initializer_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/variability_initializer_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid variability_initializer_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"variability initializer header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::variability::initializer>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n/**\n * @brief Registers all of the available feature templates with registrar.\n */\nclass <#= sn #> final {\npublic:\n    static void register_entities(variability::helpers::registrar& rg);\n};\n\n<#+\n        }\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::main",
      "documentation": "Generates implementation file for entry point.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.entry_point",
        "masd.wale.kvp.archetype.simple_name": "main",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/entry_point.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/main_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/main_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid main_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"main\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::entry_point>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nint main(int /*argc*/, char* /*argv*/[]) {\n    return 0;\n}\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>()\n<#+\n                // FIXME: this was just too hard to hack with a sequence.\n                // FIXME: indentation is all off too.\n                std::ostringstream ss;\n                bool is_first(true);\n                bool found(false);\n                for (const auto& attr : o.local_attributes()) {\n                    if (!attr.parsed_type().is_current_simple_type())\n                        continue;\n\n                    found = true;\n                    if (!is_first)\n                        ss << \",\" << std::endl << \"      \";\n\n                    ss << attr.member_variable_name()\n                       << \"(static_cast<\" << ast.get_qualified_name(attr.parsed_type())\n                       << \">(0))\";\n\n                    is_first = false;\n                }\n                ss << \" { }\";\n                const std::string out(ss.str());\n#>\n    <#= (found ? \": \" : \"\") #><#= out #>\n<#+\n            }\n\n            /*\n             * Move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>(<#= sn #>&& rhs)\n<#+\n                const auto size(o.parents().size() + o.local_attributes().size());\n\n                utility::formatters::sequence_formatter sf(size);\n                sf.prefix_configuration().first(\": \").not_first(\"  \");\n                sf.postfix_configuration().last(\" { }\");\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= sf.prefix() #><#= pqn #>(\n        std::forward<<#= pqn #>>(rhs))<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>))<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n\n            /*\n             * Complete constructor.\n             */\n            if (!o.all_attributes().empty()) {\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                     const auto attr(*o.all_attributes().begin());\n#>\n\n<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)\n<#+\n                } else {\n#>\n\n<#= sn #>::<#= sn #>(\n<#+\n\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\")\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n    const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n\n                auto sequence_size(o.local_attributes().size() + o.parents().size());\n                for (const auto& pair : o.inherited_attributes()) {\n                    const auto& pattrs(pair.second);\n                    sequence_size += (pattrs.size() > 1 ? pattrs.size() : 0);\n                }\n\n                utility::formatters::sequence_formatter sf(sequence_size);\n                sf.postfix_configuration().last(\" { }\");\n                sf.prefix_configuration().first(\": \").not_first(\"  \");\n                for (const auto& pair : o.inherited_attributes()) {\n                    const auto pqn(ast.get_qualified_name(pair.first));\n                    const auto& pattrs(pair.second);\n                    if (pattrs.size() <= 1) {\n#>\n    <#= sf.prefix() #><#= pqn #>(<#= (pattrs.empty() ? \"\" : pattrs.front().name().simple()) #>)<#= sf.postfix() #>\n<#+\n                        sf.next();\n                    } else {\n#>\n    <#= sf.prefix() #><#= pqn #>(<#= sf.postfix(true/*skip*/) #>\n<#+\n                        sf.next();\n                        utility::formatters::sequence_formatter sf2(pattrs.size());\n                        sf2.element_separator(\"\");\n\n                        sf2.prefix_configuration().first(\"  \").not_first(\"  \");\n                        sf2.postfix_configuration().last(\")\");\n                        for (const auto& attr : pattrs) {\n#>\n    <#= sf2.prefix() #><#= attr.name().simple() #><#= sf2.postfix() #><#= sf.postfix() #>\n<#+\n                            sf2.next();\n                            sf.next();\n                        }\n                    }\n                }\n\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #>(<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n\n            /*\n             * Visitation.\n             */\n            if (o.is_visitation_leaf()) {\n                std::string bvn;\n                std::string dvn;\n                std::string rpn;\n                if (o.derived_visitor()) {\n                    bvn = ast.get_qualified_name(*o.base_visitor());\n                    dvn = o.derived_visitor()->simple();\n                    rpn = ast.get_qualified_name(o.root_parents().front());\n                } else {\n                    bvn = o.base_visitor()->simple();\n                    rpn = o.root_parents().front().simple();\n                }\n#>\n\nvoid <#= sn #>::accept(const <#= bvn #>& v) const {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef const <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n\nvoid <#= sn #>::accept(<#= bvn #>& v) const {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n    }\n\nvoid <#= sn #>::accept(const <#= bvn #>& v) {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef const <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n\nvoid <#= sn #>::accept(<#= bvn #>& v) {\n<#+\n                if (o.derived_visitor()) {\n#>\n    typedef <#= dvn #>* derived_ptr;\n    const auto dv(dynamic_cast<derived_ptr>(&v));\n    if (dv)\n        dv->visit(*this);\n<#+\n                } else {\n#>\n    v.visit(*this);\n<#+\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Streaming\n             */\n            if (ast.is_io_enabled()) {\n                if (o.in_inheritance_relationship()) {\n#>\n\nvoid <#= sn #>::to_stream(std::ostream& s) const {\n<#+\n                io::inserter_implementation_helper(ast, o, true/*inside_class*/);\n#>\n}\n<#+\n                }\n            }\n\n            /*\n             * Swap\n             */\n            if (!o.is_immutable() && (!o.all_attributes().empty() || o.is_parent())) {\n                const bool empty(o.all_attributes().empty() && o.parents().empty());\n#>\n\nvoid <#= sn #>::swap(<#= sn #>&<#= (empty ? \"\" : \" other\") #>)<#= ast.make_noexcept_keyword_text() #> {\n<#+\n               if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= pqn #>::swap(other);\n\n<#+\n\n               }\n\n               if (!o.local_attributes().empty()) {\n#>\n    using std::swap;\n<#+\n                   for (const auto& attr : o.local_attributes())\n#>\n    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);\n<#+\n               }\n#>\n}\n<#+\n            }\n\n            /*\n             * Equals method\n             */\n            // FIXME: looking at root_parent as a hack due to service leafs not\n            // FIXME: being processed atm.\n            if (!o.is_parent() && !o.parents().empty() && !o.root_parents().empty()) {\n                const auto rpn(o.root_parents().front());\n#>\n\nbool <#= sn #>::equals(const <#= ast.get_qualified_name(rpn) #>& other) const {\n    const <#= sn #>* const p(dynamic_cast<const <#= sn #>* const>(&other));\n    if (!p) return false;\n    return *this == *p;\n}\n<#+\n            }\n\n            /*\n             * Equals operator\n             */\n            std::string method_name;\n            if (o.is_parent())\n                method_name = \"compare\";\n            else\n                method_name = \"operator==\";\n#>\n\nbool <#= sn #>::<#= method_name #>(const <#= sn #>& <#= (o.all_attributes().empty() ? \"/*rhs*/\" : \"rhs\") #>) const {\n<#+\n\n            if (o.all_attributes().empty())\n#>\n    return true;\n<#+\n            else {\n                utility::formatters::sequence_formatter sf(o.parents().size());\n                sf.element_separator(\"\");\n                sf.prefix_configuration().first(\"return \").not_first(\"    \");\n                sf.postfix_configuration().not_last(\" &&\");\n                if (o.local_attributes().empty())\n                    sf.postfix_configuration().last(\";\");\n                else\n                    sf.postfix_configuration().last(\" &&\");\n\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= sf.prefix() #><#= pqn #>::compare(rhs)<#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n                sf.reset(o.local_attributes().size());\n                sf.element_separator(\"\");\n                if (o.parents().empty())\n                   sf.prefix_configuration().first(\"return \");\n                else\n                   sf.prefix_configuration().first(\"    \");\n                sf.prefix_configuration().not_first(\"    \");\n                sf.postfix_configuration().last(\";\").not_last(\" &&\");\n                for (const auto& attr : o.local_attributes()) {\n#>\n    <#= sf.prefix() #><#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #><#= sf.postfix() #>\n<#+\n                    sf.next();\n                }\n            }\n#>\n}\n<#+\n\n            /*\n             * Assignment\n             */\n            if (!o.all_attributes().empty() && !o.is_parent() && !o.is_immutable()) {\n#>\n\n<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {\n    using std::swap;\n    swap(*this, other);\n    return *this;\n}\n<#+\n            }\n\n            /*\n             * Getters and setters\n             */\n             for (const auto& attr : o.local_attributes()) {\n                 if (attr.parsed_type().is_current_simple_type()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                    if (!o.is_immutable()) {\n#>\n\n<#= (attr.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {\n    <#= attr.member_variable_name() #> = v;\n<#+\n                        if (attr.is_fluent()) {\n#>\n    return *this;\n<#+\n                        }\n#>\n}\n<#+\n                    }\n                } else {\n#>\n\nconst <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                    if (!o.is_immutable()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {\n    return <#= attr.member_variable_name() #>;\n}\n\n<#= (o.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {\n    <#= attr.member_variable_name() #> = v;\n<#+\n                        if (o.is_fluent()) {\n#>\n    return *this;\n<#+\n                        }\n#>\n}\n<#+\n                        if (ast.supports_move_operator()) {\n#>\n\n<#= (o.is_fluent() ? sn + \"&\" : \"void\") #> <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {\n    <#= attr.member_variable_name() #> = std::move(v);\n<#+\n                            if (o.is_fluent()) {\n#>\n    return *this;\n<#+\n                            }\n#>\n}\n<#+\n                        }\n                    }\n                }\n            }\n#>\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::exception_header",
      "documentation": "Generates header files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.exception",
        "masd.wale.kvp.archetype.simple_name": "exception_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "type_declaration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/exception.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/exception_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/exception_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid exception_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"exception header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::exception>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(ye.documentation());\n#>\nclass <#= ye.name().simple() #> : public virtual std::exception, public virtual boost::exception {\npublic:\n<#+\n            if (ast.is_cpp_standard_98()) {\n#>\n    <#= ye.name().simple() #>() {}\n    ~<#= ye.name().simple() #>() {}\n<#+\n            } else {\n#>\n    <#= ye.name().simple() #>() = default;\n    ~<#= ye.name().simple() #>()<#= ast.make_noexcept_keyword_text() #> = default;\n<#+\n            }\n#>\n\npublic:\n    explicit <#= ye.name().simple() #>(const std::string& message) : message_(message) { }\n\npublic:\n<#+\n            if (ast.is_cpp_standard_98()) {\n                // Note: we are using BOOST_NOEXCEPT here by design. The problem is\n                // users may include this header in a C++ 98 project or in a C++ > 11 project;\n                // and we need to have different behaviours. Depending on this inclusion.\n                // If we do not, we will cause compilation errors when including C++ 98 code\n                // on a C++ 11 project. This is because the standard library will have noexcept\n                // but we won't (as we were generated for C++ 98), so we'd be weakening the exception\n                // guarantees. By using the boost macro we will do the right thing hopefully.\n                // And since we already need boost for exception, we should be ok.\n#>\n    const char* what() const BOOST_NOEXCEPT { return(message_.c_str()); }\n<#+\n            } else {\n#>\n    const char* what() const<#= ast.make_noexcept_keyword_text() #> { return(message_.c_str()); }\n<#+\n            }\n#>\n\nprivate:\n    const std::string message_;\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "type_declaration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#+\n            ast.comment(e.documentation());\n            if (ast.is_cpp_standard_98()) {\n#>\nenum <#= ye.name().simple() #> {\n<#+\n            } else {\n                if (ye.use_implementation_defined_underlying_element())\n#>\nenum class <#= ye.name().simple() #> {\n<#+\n                else\n#>\nenum class <#= ye.name().simple() #> : <#= ast.get_qualified_name(ye.underlying_element()) #> {\n<#+\n            }\n\n            utility::formatters::sequence_formatter sf(ye.enumerators().size());\n            for (const auto& en : ye.enumerators()) {\n                if (ye.use_implementation_defined_enumerator_values())\n#>\n    <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                else\n#>\n    <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                sf.next();\n            }\n#>\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::visitor_forward_declarations",
      "documentation": "Generates forward declarations for visitors.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visitor",
        "masd.wale.kvp.archetype.simple_name": "visitor_forward_declarations",
        "masd.physical.relation_status": "relatable",
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "forward declaration",
        "masd.physical.postfix": "fwd"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/visitor.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/visitor_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/visitor_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid visitor_forward_declarations_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"visitor forward declarations\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::visitor>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= o.name().simple() #>;\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto attr(p.value_attribute());\n\n            /*\n             * Default constructor.\n             */\n            if (ast.requires_manual_default_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>()\n    : <#= attr.member_variable_name() #>(static_cast<<#= ast.get_qualified_name(attr.parsed_type()) #>>(0)) { }\n<#+\n            }\n\n            /*\n             * Move constructor.\n             */\n            if (ast.requires_manual_move_constructor()) {\n#>\n\n<#= sn #>::<#= sn #>(<#= sn #>&& rhs)\n    : <#= attr.member_variable_name() #>(std::move(rhs.<#= attr.member_variable_name() #>)) { }\n<#+\n            }\n\n            /*\n             * Complete constructor.\n             */\n#>\n\n<#= sn #>::<#= sn #>(const <#= ast.get_qualified_name(attr.parsed_type()) #><#= ast.make_by_ref_text(attr) #> <#= attr.name().simple() #>)\n    : <#= attr.member_variable_name() #>(<#= attr.name().simple() #>) { }\n\n<#+\n            /*\n             * Getters and setters\n             */\n             if (attr.parsed_type().is_current_simple_type()) {\n#>\n<#= ast.get_qualified_name(attr.parsed_type()) #> <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n\n<#+\n                if (!p.is_immutable()) {\n#>\nvoid <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #> v) {\n    <#= attr.member_variable_name() #> = v;\n}\n\n<#+\n                }\n            } else {\n#>\nconst <#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() const {\n    return <#= attr.member_variable_name() #>;\n}\n<#+\n                if (!p.is_immutable()) {\n#>\n\n<#= ast.get_qualified_name(attr.parsed_type()) #>& <#= sn #>::<#= attr.name().simple() #>() {\n    return <#= attr.member_variable_name() #>;\n}\n\nvoid <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>& v) {\n    <#= attr.member_variable_name() #> = v;\n}\n\nvoid <#= sn #>::<#= attr.name().simple() #>(const <#= ast.get_qualified_name(attr.parsed_type()) #>&& v) {\n    <#= attr.member_variable_name() #> = std::move(v);\n}\n\n<#+\n                }\n            }\n\n            /*\n             * Equality.\n             */\n#>\nbool <#= sn #>::operator==(const <#= sn #>& rhs) const {\n    return <#= attr.member_variable_name() #> == rhs.<#= attr.member_variable_name() #>;\n}\n\n<#+\n            /*\n             * Swap and assignment.\n             */\n            if (!p.is_immutable()) {\n#>\nvoid <#= sn #>::swap(<#= sn #>& other)<#= ast.make_noexcept_keyword_text() #> {\n    using std::swap;\n    swap(<#= attr.member_variable_name() #>, other.<#= attr.member_variable_name() #>);\n}\n\n<#= sn #>& <#= sn #>::operator=(<#= sn #> other) {\n    using std::swap;\n    swap(*this, other);\n    return *this;\n}\n\n<#+\n            }\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types",
        "masd.label.roles": "type_declaration"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::feature_template_bundle_implementation",
      "documentation": "Generates implementation files for feature templates.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_template_bundle",
        "masd.wale.kvp.archetype.simple_name": "feature_template_bundle_implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.variability/types/helpers/enum_mapper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_template_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_template_bundle_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_template_bundle_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid feature_template_bundle_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature template bundle implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ftb(ast.as<logical::entities::variability::feature_template_bundle>(e));\n\n    {\n        const auto sn(ftb.name().simple());\n        const auto qn(ast.get_qualified_name(ftb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(ftb));\n        ast.add_helper_methods(ftb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(ftb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using namespace variability::helpers;\n            using utility::string::splitter;\n\n            if (ftb.generate_registration()) {\n#>\n\nnamespace {\n<#+\n                for (const auto& ft : ftb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(ft.key()).back());\n                    const bool has_qualified_name(simple_key != ft.key());\n#>\n\ndogen::variability::entities::feature_template\nmake_<#= ft.identifiable_key() #>() {\n    using namespace dogen::variability::entities;\n    feature_template r;\n    r.name().simple(\"<#= simple_key #>\");\n<#+\n                    if (has_qualified_name) {\n#>\n    r.name().qualified(\"<#= ft.key() #>\");\n<#+\n                    }\n#>\n    r.description(R\"(<#= ft.documentation() #>)\");\n    const auto vt(<#= enum_mapper::from_value_type(ft.value_type()) #>);\n    r.value_type(vt);\n    r.binding_point(<#= enum_mapper::from_binding_point(*ft.binding_point()) #>);\n    r.instantiation_domain_name(\"<#= ftb.instantiation_domain_name() #>\");\n<#+\n\n                    if (!ft.default_value().empty()) {\n#>\n    dogen::variability::helpers::value_factory f;\n    r.default_value(f.make(vt, std::list<std::string>{ <#= ft.default_value() #> }));\n<#+\n                        for (const auto& dvo : ft.default_value_overrides()) {\n#>\n    r.default_value_overrides().push_back(\n        default_value_override(\"<#= dvo.key_ends_with() #>\",\n            f.make(vt, std::list<std::string>{ <#= dvo.default_value() #> })));\n<#+\n                       }\n                   }\n#>\n    return r;\n}\n<#+\n                }\n#>\n\n}\n\n<#+\n            }\n\n            if (ftb.generate_static_configuration()) {\n#>\n<#= sn #>::feature_group\n<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {\n    feature_group r;\n    const dogen::variability::helpers::feature_selector s(fm);\n\n<#+\n                for (const auto& ft : ftb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(ft.key()).back());\n#>\n    r.<#= simple_key #> = s.get_by_name(\"<#= ft.key() #>\");\n<#+\n                }\n#>\n\n    return r;\n}\n\n<#= sn #>::static_configuration <#= sn #>::make_static_configuration(\n    const feature_group& fg,\n    const dogen::variability::entities::configuration& cfg) {\n\n    static_configuration r;\n    const dogen::variability::helpers::configuration_selector s(cfg);\n<#+\n                for (const auto& ft : ftb.feature_templates()) {\n                    const auto simple_key(splitter::split_scoped(ft.key()).back());\n\n                    const bool has_default_value(!ft.default_value().empty());\n                    if (has_default_value) {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);\n<#+\n                    } else if (ft.is_optional()) {\n#>\n    if (s.has_configuration_point(fg.<#= simple_key #>))\n        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    } else {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(ft.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    }\n                }\n#>\n    return r;\n}\n<#+\n            }\n\n            if (ftb.generate_registration()) {\n\n#>\n\nstd::list<dogen::variability::entities::feature_template>\n<#= sn #>::make_templates() {\n    using namespace dogen::variability::entities;\n    std::list<dogen::variability::entities::feature_template> r;\n<#+\n\n                for (const auto& ft : ftb.feature_templates()) {\n#>\n    r.push_back(make_<#= ft.identifiable_key() #>());\n<#+\n                }\n#>\n    return r;\n}\n\n<#+\n            }\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::feature_bundle_implementation",
      "documentation": "Generates implementation files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_feature_bundle",
        "masd.wale.kvp.archetype.simple_name": "feature_bundle_implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/string/splitter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.variability/types/helpers/enum_mapper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/feature_bundle.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_bundle_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/feature_bundle_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid feature_bundle_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"feature bundle implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& fb(ast.as<logical::entities::variability::feature_bundle>(e));\n\n    {\n        const auto sn(fb.name().simple());\n        const auto qn(ast.get_qualified_name(fb.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(fb));\n        ast.add_helper_methods(fb.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(fb.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            using namespace variability::helpers;\n            using utility::string::splitter;\n\n            if (fb.generate_registration()) {\n#>\n\nnamespace {\n<#+\n                for (const auto& f : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(f.key()).back());\n                    const bool has_qualified_name(simple_key != f.key());\n#>\n\ndogen::variability::entities::feature\nmake_<#= f.identifiable_key() #>() {\n    using namespace dogen::variability::entities;\n    feature r;\n    r.name().simple(\"<#= simple_key #>\");\n<#+\n                   if (has_qualified_name) {\n#>\n    r.name().qualified(\"<#= f.key() #>\");\n<#+\n                   }\n#>\n    r.description(R\"(<#= f.documentation() #>)\");\n    const auto vt(<#= enum_mapper::from_value_type(f.value_type()) #>);\n    r.value_type(vt);\n<#+\n                   if (f.unparsed_type() == \"masd::variability::key_value_pair\") {\n#>\n    r.is_partially_matchable(true);\n<#+\n                   }\n#>\n    r.binding_point(<#= enum_mapper::from_binding_point(*f.binding_point()) #>);\n<#+\n                   if (!f.default_value().empty()) {\n#>\n    dogen::variability::helpers::value_factory f;\n    r.default_value(f.make(vt, std::list<std::string>{ <#= f.default_value() #> }));\n<#+\n                   }\n#>\n    return r;\n}\n<#+\n                }\n#>\n\n}\n\n<#+\n            }\n\n            if (fb.generate_static_configuration()) {\n#>\n<#= sn #>::feature_group\n<#= sn #>::make_feature_group(const dogen::variability::entities::feature_model& fm) {\n    feature_group r;\n    const dogen::variability::helpers::feature_selector s(fm);\n\n<#+\n                for (const auto& f : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(f.key()).back());\n#>\n    r.<#= simple_key #> = s.get_by_name(\"<#= f.key() #>\");\n<#+\n                }\n#>\n\n    return r;\n}\n\n<#= sn #>::static_configuration <#= sn #>::make_static_configuration(\n    const feature_group& fg,\n    const dogen::variability::entities::configuration& cfg) {\n\n    static_configuration r;\n    const dogen::variability::helpers::configuration_selector s(cfg);\n<#+\n                for (const auto& f : fb.features()) {\n                    const auto simple_key(splitter::split_scoped(f.key()).back());\n\n                    const bool has_default_value(!f.default_value().empty());\n                    if (has_default_value) {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content_or_default(fg.<#= simple_key #>);\n<#+\n                    } else if (f.is_optional()) {\n#>\n    if (s.has_configuration_point(fg.<#= simple_key #>))\n        r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    } else {\n#>\n    r.<#= simple_key #> = s.get_<#= enum_mapper::from_value_type(f.value_type(), false/*simple*/) #>_content(fg.<#= simple_key #>);\n<#+\n                    }\n                }\n#>\n    return r;\n}\n<#+\n            }\n\n            if (fb.generate_registration()) {\n#>\n\nstd::list<dogen::variability::entities::feature>\n<#= sn #>::make_features() {\n    using namespace dogen::variability::entities;\n    std::list<dogen::variability::entities::feature> r;\n<#+\n\n                for (const auto& f : fb.features()) {\n#>\n    r.push_back(make_<#= f.identifiable_key() #>());\n<#+\n                }\n#>\n    return r;\n}\n\n<#+\n            }\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::types::variability_initializer_implementation",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.variability_initializer",
        "masd.wale.kvp.archetype.simple_name": "variability_initializer_implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/variability/initializer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/variability_initializer_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/types/variability_initializer_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid variability_initializer_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"variability initializer implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::variability::initializer>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nvoid <#= sn #>::\nregister_entities(variability::helpers::registrar& rg) {\n<#+\n            for (const auto& n : o.feature_template_bundles())\n#>\n    rg.register_templates(<#= n.qualified().colon() #>::make_templates());\n<#+\n            if (!o.feature_bundles().empty()) {\n                for (const auto& n : o.feature_bundles())\n#>\n    rg.register_features(<#= n.qualified().colon() #>::make_features());\n<#+\n            }\n#>\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::inserter_implementation_helper",
      "stereotypes": [
        "dogen::handcrafted::typeable"
      ],
      "fallback_element_type": "masd::object"
    },
    {
      "name": "transforms::cpp::hash::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/helper_properties.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    const auto sn(o.name().simple());\n    const auto qn(ast.get_qualified_name(o.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstruct <#= sn #>_hasher {\npublic:\n    static std::size_t hash(const <#= sn #>& v);\n};\n\n<#+\n        } // snf\n#>\n\nnamespace std {\n\ntemplate<>\nstruct hash<<#= qn #>> {\npublic:\n    size_t operator()(const <#= qn #>& v) const {\n        return <#= qn #>_hasher::hash(v);\n    }\n};\n\n}\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\nnamespace {\n\n<#+\n        if (!o.local_attributes().empty() || !o.parents().empty()) {\n#>\ntemplate <typename HashableType>\ninline void combine(std::size_t& seed, const HashableType& value) {\n    std::hash<HashableType> hasher;\n    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n<#+\n        }\n\n        ast.add_helper_methods(o.name().qualified().dot());\n#>\n\n}\n\n<#+\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple());\n            const auto qn(ast.get_qualified_name(o.name()));\n\n#>\n\nstd::size_t <#= sn #>_hasher::hash(const <#= sn #>&<#= ((o.local_attributes().empty() && o.parents().empty()) ? \"\" : \" v\") #>) {\n    std::size_t seed(0);\n<#+\n            if (!o.parents().empty()) {\n#>\n\n<#+\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    combine(seed, dynamic_cast<const <#= pqn #>&>(v));\n<#+\n            }\n\n            if (!o.local_attributes().empty()) {\n#>\n\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    if (ast.requires_hashing_helper_method(attr))\n#>\n    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));\n<#+\n                    else\n#>\n    combine(seed, v.<#= attr.name().simple() #>());\n<#+\n                }\n\n                if (o.local_attributes().size() > 1)\n#>\n\n<#+\n            }\n#>\n    return seed;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\nnamespace std {\n\ntemplate<>\nstruct hash<<#= ast.get_qualified_name(ye.name()) #>> {\npublic:\n    size_t operator()(const <#= ast.get_qualified_name(ye.name()) #>& v) const {\n        return std::hash<unsigned int>()(static_cast<unsigned int>(v));\n    }\n};\n\n}\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstruct <#= sn #>_hasher {\npublic:\n    static std::size_t hash(const <#= sn #>& v);\n};\n\n<#+\n        } // snf\n#>\n\nnamespace std {\n\ntemplate<>\nstruct hash<<#= qn #>> {\npublic:\n    size_t operator()(const <#= qn #>& v) const {\n        return <#= qn #>_hasher::hash(v);\n    }\n};\n\n}\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::hash::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.hash"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::hash #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/hash/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\nnamespace {\n\ntemplate <typename HashableType>\ninline void combine(std::size_t& seed, const HashableType& value) {\n    std::hash<HashableType> hasher;\n    seed ^= hasher(value) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\n<#+\n\n        ast.add_helper_methods(p.name().qualified().dot());\n#>\n\n}\n\n<#+\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(p.name().simple());\n            const auto qn(ast.get_qualified_name(p.name()));\n            const auto attr(p.value_attribute());\n#>\n\nstd::size_t <#= sn #>_hasher::hash(const <#= sn #>& v) {\n    std::size_t seed(0);\n<#+\n            if (ast.requires_hashing_helper_method(attr))\n#>\n    combine(seed, hash_<#= attr.parsed_type().qualified().identifiable() #>(v.<#= attr.name().simple() #>()));\n<#+\n            else\n#>\n    combine(seed, v.<#= attr.name().simple() #>());\n    return seed;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::build::include_cmakelists",
      "documentation": "Generates cmakelists for tests.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.build_cmakelists",
        "masd.wale.kvp.archetype.simple_name": "include_cmakelists",
        "masd.wale.kvp.meta_element": "build_cmakelists",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_include_cmakelists",
        "masd.wale.kvp.containing_namespace": "text.transforms.build",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "cmake"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::build #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/build/cmakelists.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/build/include_cmakelists_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/build/include_cmakelists_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid include_cmakelists_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"include cmakelists\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::build::cmakelists;\n    const auto& c(ast.as<cmakelists>(e));\n\n    {\n        const auto ts(identification::entities::technical_space::cmake);\n        ast.make_decoration_preamble(e, ts);\n#>\nadd_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.source_directory_name() #>)\n<#+\n       if (ast.is_tests_enabled()) {\n#>\nadd_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/<#= c.tests_directory_name() #>)\n<#+\n       }\n#>\n\ninstall(\n    DIRECTORY <#= c.include_directory_path() #>/\n    DESTINATION <#= c.include_directory_path() #>/\n    COMPONENT headers\n    FILES_MATCHING PATTERN \"*.<#= c.header_file_extension() #>\")\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::build::source_cmakelists",
      "documentation": "Generates cmakelists for tests.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.build_cmakelists",
        "masd.wale.kvp.archetype.simple_name": "source_cmakelists",
        "masd.wale.kvp.meta_element": "build_cmakelists",
        "masd.wale.kvp.meta_name_factory": "logical::helpers::meta_name_factory",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.locator_function": "make_full_path_for_source_cmakelists",
        "masd.wale.kvp.containing_namespace": "text.transforms.build",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "cmake"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::build #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/build/cmakelists.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/build/source_cmakelists_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/build/source_cmakelists_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid source_cmakelists_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"source cmakelists\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::build::cmakelists;\n    const auto& c(ast.as<cmakelists>(e));\n\n    {\n        const auto ts(identification::entities::technical_space::cmake);\n        ast.make_decoration_preamble(e, ts);\n        const auto model_name(ast.get_dot_separated_model_name(c.name()));\n        const auto product_name(ast.get_product_name(c.name()));\n#>\nset(name \"<#= model_name #>\")\nset(lib_binary_name ${name})\nset(lib_target_name ${name}.lib)\n\nset(files \"\")\nfile(GLOB_RECURSE files RELATIVE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>\")\n\n<#+\n        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {\n#>\nset(odb_files \"\")\nfile(GLOB_RECURSE odb_files RELATIVE\n   \"${CMAKE_CURRENT_SOURCE_DIR}/\"\n   \"${CMAKE_CURRENT_SOURCE_DIR}/*.cxx\")\nset(files ${files} ${odb_files})\n\n<#+\n        }\n#>\nset(lib_files ${files})\nadd_library(${lib_target_name} ${lib_files})\nset_target_properties(${lib_target_name} PROPERTIES\n<#+\n        if (ast.is_cpp_standard_98()) {\n#>\n    CXX_STANDARD 98\n<#+\n        }\n#>\n    OUTPUT_NAME ${lib_binary_name})\n\ninstall(TARGETS ${lib_target_name}\n    ARCHIVE DESTINATION lib\n    LIBRARY DESTINATION lib\n    COMPONENT libraries)\n<#+\n        if (ast.is_odb_facet_enabled() && !c.odb_targets().targets().empty()) {\n            const auto targets(c.odb_targets());\n#>\n\n#\n# ODB Executable Targets\n#\nif (ODB_EXECUTABLE)\n    # Top-level targets\n    add_custom_target(<#= targets.main_target_name() #>)\n    add_dependencies(odb_all <#= targets.main_target_name() #>)\n\n    if (NOT ODB_EXECUTABLE_GLOBAL_ARGS)\n        message(WARNING \"ODB_EXECUTABLE_GLOBAL_ARGS not defined. Inclusion errors likely when running ODB targets.\")\n    endif()\n\n<#+\n            for (const auto& target : targets.targets()) {\n#>\n\n    add_custom_target(<#= target.name() #>\n        COMMENT \"<#= target.comment() #>\"\n        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}\n        COMMAND ${ODB_EXECUTABLE}\n            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= targets.common_odb_options() #>\n            --options-file ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.object_odb_options() #>\n            --output-dir ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.output_directory() #>\n            ${ODB_EXECUTABLE_GLOBAL_ARGS}\n            ${CMAKE_CURRENT_SOURCE_DIR}/<#= target.types_file() #>\n<#+\n                for (const auto& pair : target.move_parameters())\n#>\n        COMMAND mv ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.first #> ${CMAKE_CURRENT_SOURCE_DIR}/<#= pair.second #>\n        VERBATIM\n    )\n    add_dependencies(<#= targets.main_target_name() #> <#= target.name() #>)\n<#+\n            }\n#>\nendif()\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::project",
      "documentation": "FIXME: to be removed.\n",
      "stereotypes": [
        "masd::physical::part"
      ],
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "external_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "model_modules_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "facet_path_contribution",
          "type": "",
          "value": "none"
        },
        {
          "name": "requires_relative_path",
          "type": "",
          "value": "false"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto qn(ast.get_qualified_name(o.name()));\n#>\n\nstd::ostream&\noperator<<(std::ostream& s,\n     const <#= qn #>& v);\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(o.name().simple());\n            const auto qn(ast.get_qualified_name(o.name()));\n            const bool no_arg(!o.is_parent() && o.parents().empty() &&\n                o.local_attributes().empty());\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= sn #>&<#= (no_arg ? \"\" : \" v\")  #>) {\n<#+\n            if (o.is_parent() || !o.parents().empty()) {\n#>\n    v.to_stream(s);\n    return(s);\n<#+\n            } else\n                io::inserter_implementation_helper(ast, o, false/*inside_class*/);\n#>\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v);\n\n<#+\n         } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::enum_implementation",
      "documentation": "Generates implementation files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/enum_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/enum_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= ye.name().simple() #>& v) {\n    s << \"{ \" << \"\\\"__type__\\\": \" << \"\\\"<#= ye.name().simple() #>\\\", \" << \"\\\"value\\\": \";\n\n    std::string attr;\n    switch (v) {\n<#+\n            for (const auto& en : ye.enumerators()) {\n                if (ast.is_cpp_standard_98())\n#>\n    case <#= en.name().simple() #>:\n<#+\n                else\n#>\n    case <#= ye.name().simple() #>::<#= en.name().simple() #>:\n        attr = \"\\\"<#= en.name().simple() #>\\\"\";\n        break;\n<#+\n            }\n#>\n    default:\n        throw std::invalid_argument(\"Invalid value for <#= ye.name().simple() #>\");\n    }\n    s << attr << \" }\";\n    return s;\n}\n\n<#+\n         } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto qn(ast.get_qualified_name(p.name()));\n#>\n\nstd::ostream&\noperator<<(std::ostream& s, const <#= qn #>& v);\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::io::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/inserter_implementation_helper.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/io/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(p.name().qualified().dot());\n\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(p.name().simple());\n            const auto qn(ast.get_qualified_name(p.name()));\n            const auto attr(p.value_attribute());\n#>\n\nstd::ostream& operator<<(std::ostream& s, const <#= sn #>& v) {\n<#+\n            if (ast.requires_stream_manipulators()) {\n#>\n    boost::io::ios_flags_saver ifs(s);\n    s.setf(std::ios_base::boolalpha);\n    s.setf(std::ios::fixed, std::ios::floatfield);\n    s.precision(6);\n    s.setf(std::ios::showpoint);\n<#+\n            }\n\n            const std::string variable_name = \"v.\" + attr.getter_setter_name() + \"()\";\n#>\n\n    s << \" { \"\n      << \"\\\"__type__\\\": \" << \"\\\"<#= qn #>\\\"\" << \", \"\n      << \"\\\"<#= attr.name().simple() #>\\\": \" << <#= ast.streaming_for_type(attr.parsed_type().current(), variable_name) #>\n      << \" }\";\n\n    return s;\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::class_header",
      "documentation": "Generates header files for archetypes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n\n        if (!o.orm_properties() || o.orm_properties()->odb_pragmas().empty()) {\n#>\n// class has no ODB pragmas defined.\n\n<#+\n        } else {\n            {\n                const auto ns(ast.make_namespaces(o.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n#ifdef ODB_COMPILER\n\n<#+\n                for (const auto& pg : o.orm_properties()->odb_pragmas())\n#>\n<#= pg #>\n<#+\n\n                bool is_first(true);\n                for (const auto& attr : o.local_attributes()) {\n                    if (!attr.orm_properties() ||\n                        attr.orm_properties()->odb_pragmas().empty())\n                        continue;\n\n                    const auto attr_level_pragmas(attr.orm_properties()->odb_pragmas());\n                    for (const auto& pg : attr_level_pragmas) {\n                        if (is_first)\n#>\n\n<#+\n                        is_first = false;\n#>\n<#= pg #>\n<#+\n                    }\n                }\n#>\n\n#endif\n\n<#+\n            }\n#>\n\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n#ifdef ODB_COMPILER\n\n#endif\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        const auto sn(p.name().simple());\n        const auto qn(ast.get_qualified_name(p.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        const auto attr(p.value_attribute());\n\n        if (!p.orm_properties() || p.orm_properties()->odb_pragmas().empty()) {\n#>\n// class has no ODB pragmas defined.\n\n<#+\n        } else {\n            {\n                const auto ns(ast.make_namespaces(p.name()));\n                auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n#ifdef ODB_COMPILER\n\n<#+\n                for (const auto& pg : p.orm_properties()->odb_pragmas())\n#>\n<#= pg #>\n<#+\n\n                bool is_first(true);\n                if (p.value_attribute().orm_properties() &&\n                    !p.value_attribute().orm_properties()->odb_pragmas().empty()) {\n                    for (const auto& pg : p.value_attribute().orm_properties()->odb_pragmas()) {\n                        if (is_first)\n#>\n\n<#+\n                            is_first = false;\n#>\n<#= pg #>\n<#+\n                    }\n#>\n\n#endif\n\n<#+\n                }\n            }\n#>\n\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::object_odb_options",
      "documentation": "Generates object options for odb.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.class.simple_name": "object_odb_options_transform",
        "masd.wale.kvp.archetype.simple_name": "object_odb_options",
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.odb",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/object_odb_options_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/object_odb_options_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid object_odb_options_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"object odb options\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto ts(identification::entities::technical_space::odb);\n        ast.make_decoration_preamble(e, ts);\n\n        if (!o.orm_properties()) {\n#>\n\n#\n# class has no ODB options defined.\n#\n<#+\n        } else {\n            const auto ooo(o.orm_properties()->odb_options());\n#>\n# epilogue\n--odb-epilogue <#= ooo.epilogue() #>\n\n<#+\n            if (!ooo.include_regexes().empty()) {\n#>\n# regexes\n<#+\n                for (const auto& regex : ooo.include_regexes())\n#>\n--include-regex <#= regex #>\n\n# debug regexes\n# --include-regex-trace\n\n# make the header guards similar to dogen ones\n--guard-prefix <#= ooo.header_guard_prefix() #>\n<#+\n            }\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::primitive_odb_options",
      "documentation": "Generates object options for odb.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.kvp.archetype.simple_name": "primitive_odb_options",
        "masd.wale.kvp.meta_element": "primitive",
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.odb",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/primitive_odb_options_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/primitive_odb_options_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_odb_options_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive odb options\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        const auto ts(identification::entities::technical_space::odb);\n        ast.make_decoration_preamble(e, ts);\n\n        if (!p.orm_properties()) {\n#>\n\n#\n# class has no ODB options defined.\n#\n<#+\n        } else {\n            const auto ooo(p.orm_properties()->odb_options());\n#>\n# epilogue\n--odb-epilogue <#= ooo.epilogue() #>\n\n<#+\n            if (!ooo.include_regexes().empty()) {\n#>\n# regexes\n<#+\n                for (const auto& regex : ooo.include_regexes())\n#>\n--include-regex <#= regex #>\n\n# debug regexes\n# --include-regex-trace\n\n# make the header guards similar to dogen ones\n--guard-prefix <#= ooo.header_guard_prefix() #>\n<#+\n            }\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::odb::common_odb_options",
      "documentation": "Generates object options for odb.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.orm_common_odb_options",
        "masd.wale.kvp.archetype.simple_name": "common_odb_options",
        "masd.physical.part_id": "masd.cpp.implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.odb",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "odb"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::odb #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/orm/common_odb_options.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/common_odb_options_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/odb/common_odb_options_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid common_odb_options_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"common odb options\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::orm::common_odb_options;\n    const auto& o(ast.as<common_odb_options>(e));\n\n    {\n        const auto ts(identification::entities::technical_space::odb);\n        ast.make_decoration_preamble(e, ts);\n\n        if (!ast.is_cpp_standard_98()) {\n#>\n# enable C++11\n--std c++11\n\n<#+\n        }\n\n        if (!o.sql_name_case().empty()) {\n#>\n# casing\n--sql-name-case <#= o.sql_name_case() #>\n\n<#+\n        }\n\n        if (o.databases().size() > 1) {\n#>\n# enable multi-database support\n--multi-database static\n\n<#+\n        }\n\n        if (!o.databases().empty()) {\n#>\n# target databases\n<#+\n\n            for (const auto& d : o.databases())\n#>\n--database <#= d #>\n\n<#+\n        }\n#>\n# use the boost profile\n--profile boost\n\n# generate queries and embedded schemas\n--generate-query\n--generate-schema\n--schema-format embedded\n\n# force odb extensions to be different from dogen ones just in case.\n--ixx-suffix .ixx\n--hxx-suffix .hxx\n--cxx-suffix .cxx\n\n# debug regexes\n# --include-regex-trace\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::tests::class_implementation",
      "documentation": "Generates tests for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::tests_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.archetype.simple_name": "class_implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.tests"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto list(e.name().location().internal_modules());\n        list.push_back(o.name().simple());\n        const std::string test_suite_name(boost::join(list, \"_\"));\n\n        std::string type_name(\"auto\");\n        if (ast.is_cpp_standard_98())\n            type_name = qn;\n\n#>\nBOOST_AUTO_TEST_SUITE(<#= test_suite_name #>_tests)\n\n<#+\n        /*\n         * If we have no attributes at all, we cannot test this\n         * type. Similarly, if test data is not enabled, none of the\n         * tests can be generated. In either case, we need to insert a\n         * fake test for now. The real solution will be to filter\n         * based on element state.\n         */\n        if (o.all_attributes().empty() || !ast.is_test_data_enabled()) {\n            /*\n             * No tests.\n             */\n#>\nBOOST_AUTO_TEST_CASE(fake_test) {\n    BOOST_CHECK(true);\n}\n\n<#+\n        } else {\n            /*\n             * Types tests. These cannot be performed to parents as\n             * they are abstract.\n             */\n            if (!o.is_parent()) {\n#>\nBOOST_AUTO_TEST_CASE(identical_objects_are_equal) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n\n    BOOST_CHECK(a == b);\n    BOOST_CHECK(b == a);\n    BOOST_CHECK(!(a != b));\n}\n\nBOOST_AUTO_TEST_CASE(an_object_is_equal_to_itself) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    BOOST_CHECK(a == a);\n    BOOST_CHECK(!(a != a));\n}\n\nBOOST_AUTO_TEST_CASE(distinct_objects_are_unequal) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    BOOST_CHECK(!(a == b));\n    BOOST_CHECK(a != b);\n}\n\n<#+\n                if (!o.is_immutable()) {\n#>\nBOOST_AUTO_TEST_CASE(assigning_an_object_to_itself_results_in_the_same_object) {\n#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wself-assign-overloaded\"\n#endif\n    <#= qn #>_generator g;\n    <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n    const <#= type_name #> c(g());\n\n    a = a;\n    BOOST_CHECK(a == b);\n    BOOST_CHECK(a != c);\n#if defined(__clang__) && !defined(__apple_build_version__)  && (__clang_major__ >= 7)\n#pragma clang diagnostic pop\n#endif\n}\n\n<#+\n                }\n\n                // FIXME: should be 11 or greater.\n                if (!ast.is_cpp_standard_98()) {\n#>\nBOOST_AUTO_TEST_CASE(moved_objects_are_equal) {\n    <#= qn #>_generator g;\n    g();\n    <#= type_name #> a(g());\n    const <#= type_name #> b = <#= qn #>();\n    const <#= type_name #> c(a);\n    BOOST_CHECK(a != b);\n    BOOST_CHECK(a == c);\n\n    const <#= type_name #> d = std::move(a);\n    BOOST_CHECK(d == c);\n    BOOST_CHECK(d != b);\n}\n\n<#+\n                }\n\n                if (!o.is_immutable()) {\n#>\nBOOST_AUTO_TEST_CASE(assigned_objects_are_equal) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    <#= qn #> b;\n    BOOST_CHECK(a != b);\n\n    b = a;\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(copy_constructed_objects_are_equal) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    <#= type_name #> b(a);\n    BOOST_CHECK(a == b);\n\n    b = <#= qn #>();\n    BOOST_CHECK(a != b);\n}\n\nBOOST_AUTO_TEST_CASE(swapping_objects_results_in_the_expected_state) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    <#= type_name #> c(a);\n    <#= type_name #> d(b);\n    BOOST_CHECK(c == a);\n    BOOST_CHECK(d == b);\n\n    std::swap(c, d);\n    BOOST_CHECK(c == b);\n    BOOST_CHECK(d == a);\n}\n\n<#+\n                }\n            }\n\n            if (ast.is_io_enabled()) {\n                /*\n                 * IO tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {\n<#+\n                if (o.is_parent()) {\n#>\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n    std::stringstream s;\n    s << *a;\n\n    boost::property_tree::ptree pt;\n    BOOST_REQUIRE_NO_THROW(read_json(s, pt));\n<#+\n                } else {\n#>\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    std::stringstream s;\n    s << a;\n\n    boost::property_tree::ptree pt;\n    BOOST_REQUIRE_NO_THROW(read_json(s, pt));\n<#+\n                }\n#>\n}\n\n<#+\n            }\n\n            if (ast.is_serialization_enabled()) {\n                /*\n                 * Serialization tests.\n                 */\n                 const auto registrar_qn(o.type_registrar() ?\n                     ast.get_qualified_name(*o.type_registrar()) : std::string());\n\n                if (o.is_parent()) {\n#>\nBOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_oarchive>(oa);\n<#+\n                    }\n#>\n\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    boost::shared_ptr<<#= qn #>> b;\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n\n    BOOST_REQUIRE(a);\n    BOOST_REQUIRE(b);\n    BOOST_CHECK(*a == *b);\n}\n\nBOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        text_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    boost::shared_ptr<<#= qn #>> b;\n    std::istringstream is(os.str());\n    {\n        text_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_REQUIRE(a);\n    BOOST_REQUIRE(b);\n    BOOST_CHECK(*a == *b);\n}\n\nBOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const boost::shared_ptr<<#= qn #>> a(g.create_ptr(1));\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        binary_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    boost::shared_ptr<<#= qn #>> b;\n    std::istringstream is(os.str());\n    {\n        binary_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_REQUIRE(a);\n    BOOST_REQUIRE(b);\n    BOOST_CHECK(*a == *b);\n}\n\n<#+\n                } else {\n\n#>\nBOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<xml_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        text_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        text_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<text_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        binary_oarchive oa(os);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_oarchive>(oa);\n<#+\n                    }\n#>\n        oa << a;\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        binary_iarchive ia(is);\n<#+\n                    if (o.type_registrar()) {\n#>\n        <#= registrar_qn #>::register_types<binary_iarchive>(ia);\n<#+\n                    }\n#>\n        ia >> b;\n    }\n\n    BOOST_CHECK(a == b);\n}\n<#+\n                }\n            }\n\n            if (ast.is_hash_enabled() && !o.is_parent()) {\n                /*\n                 * hash tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(equal_objects_generate_the_same_hash) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) == hasher(b));\n}\n\nBOOST_AUTO_TEST_CASE(different_objects_generate_different_hashes) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) != hasher(b));\n}\n\n<#+\n            }\n        }\n#>\nBOOST_AUTO_TEST_SUITE_END()\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::tests::main",
      "documentation": "Generates entry point for tests.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::tests_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.entry_point",
        "masd.wale.kvp.archetype.simple_name": "main",
        "masd.wale.kvp.containing_namespace": "text.transforms.tests"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/entry_point.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/main_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/main_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid main_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"main\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::structural::entry_point;\n    const auto& ep(ast.as<entry_point>(e));\n    const auto qn(ast.get_qualified_name(ep.name()));\n#>\n#define BOOST_TEST_MODULE <#= qn #>\n\n<#+\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(ep));\n#>\n\nnamespace  {\n\nconst std::string error_msg(\"Error during test.\");\n\ninline void translate(const boost::exception& e) {\n    std::cerr << std::endl << boost::diagnostic_information(e);\n    throw std::runtime_error(error_msg);\n}\n\nstruct exception_fixture {\n    exception_fixture() {\n        using boost::exception;\n        using boost::unit_test::unit_test_monitor;\n        unit_test_monitor.register_exception_translator<exception>(&translate);\n    }\n};\n\n}\n\nBOOST_GLOBAL_FIXTURE(exception_fixture);\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::tests::enum_implementation",
      "documentation": "Generates tests for enumeration.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::tests_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.enumeration",
        "masd.wale.kvp.archetype.simple_name": "enum_implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.tests"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/predef.h>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/enum_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/enum_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        const auto qn(ast.get_qualified_name(e.name()));\n        const auto sn(e.name().simple());\n        std::string type_name(\"auto\");\n        if (ast.is_cpp_standard_98())\n            type_name = qn;\n#>\nBOOST_AUTO_TEST_SUITE(<#= e.name().simple() #>_tests)\n\n<#+\n        /*\n         * If test data is not enabled, none of the tests can be\n         * generated. We need to insert a fake test for now. The real\n         * solution will be to filter based on element state.\n         */\n        if (!ast.is_test_data_enabled()) {\n            /*\n             * No tests.\n             */\n#>\nBOOST_AUTO_TEST_CASE(fake_test) {\n    BOOST_CHECK(true);\n}\n\n<#+\n        } else {\n            if (ast.is_io_enabled()) {\n                /*\n                 * IO tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(inserter_operator_produces_valid_json) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n    std::stringstream s;\n    s << a;\n\n    boost::property_tree::ptree pt;\n    BOOST_REQUIRE_NO_THROW(read_json(s, pt));\n}\n\n<#+\n            }\n\n            if (ast.is_lexical_cast_enabled()) {\n                /*\n                 * Lexical cast tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(casting_valid_strings_produces_expected_enumeration) {\n    using <#= qn #>;\n    <#= sn #> r;\n<#+\n        for (const auto& enu : enm.enumerators()) {\n            const auto enu_sn(enu.name().simple());\n            std::string enu_qn;\n            if (ast.is_cpp_standard_98())\n                enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n            else\n                enu_qn = sn + \"::\" + enu_sn;\n#>\n\n    r = boost::lexical_cast<<#= sn #>>(std::string(\"<#= enu_sn #>\"));\n    BOOST_CHECK(r == <#= enu_qn #>);\n    r = boost::lexical_cast<<#= sn #>>(std::string(\"<#= sn + \"::\" + enu_sn #>\"));\n    BOOST_CHECK(r == <#= enu_qn #>);\n<#+\n        }\n#>\n}\n\nBOOST_AUTO_TEST_CASE(casting_invalid_string_throws) {\n    using <#= qn #>;\n    BOOST_CHECK_THROW(boost::lexical_cast<<#= sn #>>(std::string(\"DOGEN_THIS_IS_INVALID_DOGEN\")),\n        boost::bad_lexical_cast);\n}\n\nBOOST_AUTO_TEST_CASE(casting_valid_enumerations_produces_expected_strings) {\n    using <#= qn #>;\n    std::string r;\n<#+\n        for (const auto& enu : enm.enumerators()) {\n            const auto enu_sn(enu.name().simple());\n            std::string enu_qn;\n            if (ast.is_cpp_standard_98())\n                enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n            else\n                enu_qn = sn + \"::\" + enu_sn;\n\n#>\n\n    r = boost::lexical_cast<std::string>(<#= enu_qn #>);\n    BOOST_CHECK(r == \"<#= sn + \"::\" + enu_sn #>\");\n<#+\n        }\n#>\n}\n\nBOOST_AUTO_TEST_CASE(casting_invalid_enumeration_throws) {\n#if BOOST_COMP_GNUC\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\n#endif\n    using <#= qn #>;\n    const <#= sn #> r(static_cast<<#= sn #>>(<#= enm.enumerators().size() + 10 #>));\n#if BOOST_COMP_GNUC\n#pragma GCC diagnostic pop\n#endif\n    BOOST_CHECK_THROW(boost::lexical_cast<std::string>(r),\n        boost::bad_lexical_cast);\n}\n\n<#+\n            }\n\n            if (ast.is_serialization_enabled()) {\n                /*\n                 * Serialization tests.\n                 */\n#>\nBOOST_AUTO_TEST_CASE(xml_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(text_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        xml_oarchive oa(os);\n        oa << BOOST_SERIALIZATION_NVP(a);\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        xml_iarchive ia(is);\n        ia >> BOOST_SERIALIZATION_NVP(b);\n    }\n    BOOST_CHECK(a == b);\n}\n\nBOOST_AUTO_TEST_CASE(binary_roundtrip_produces_the_same_entity) {\n    <#= qn #>_generator g;\n    const <#= type_name #> a(g());\n\n    using namespace boost::archive;\n    std::ostringstream os;\n    {\n        text_oarchive oa(os);\n        oa << a;\n    }\n\n    <#= qn #> b = <#= qn #>();\n    std::istringstream is(os.str());\n    {\n        text_iarchive ia(is);\n        ia >> b;\n    }\n    BOOST_CHECK(a == b);\n}\n\n<#+\n            }\n\n             if (ast.is_hash_enabled()) {\n                 /*\n                  * hash tests.\n                  */\n#>\nBOOST_AUTO_TEST_CASE(equal_enums_generate_the_same_hash) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(a);\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) == hasher(b));\n}\n\nBOOST_AUTO_TEST_CASE(different_enums_generate_different_hashes) {\n    <#= qn #>_generator g;\n    g();\n    const <#= type_name #> a(g());\n    const <#= type_name #> b(g());\n\n    std::hash<<#= qn #>> hasher;\n    BOOST_CHECK(hasher(a) != hasher(b));\n}\n\n<#+\n            }\n        }\n#>\nBOOST_AUTO_TEST_SUITE_END()\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::tests::cmakelists",
      "documentation": "Generates cmakelists for tests.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.build_cmakelists",
        "masd.wale.kvp.archetype.simple_name": "cmakelists",
        "masd.physical.part_id": "masd.cpp.testing",
        "masd.wale.kvp.containing_namespace": "text.transforms.tests",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "cmake"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::tests #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/case_conv.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/build/cmakelists.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/cmakelists_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/tests/cmakelists_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid cmakelists_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"cmakelists\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::build::cmakelists;\n    const auto& c(ast.as<cmakelists>(e));\n\n    {\n\n        const auto ts(identification::entities::technical_space::cmake);\n        ast.make_decoration_preamble(e, ts);\n        const auto model_name(ast.get_dot_separated_model_name(c.name()));\n        const auto product_name(ast.get_product_name(c.name()));\n#>\nset(name \"<#= model_name #>\")\nset(lib_target_name ${name}.lib)\nset(tests_binary_name ${name}.<#= c.tests_directory_name() #>)\nset(tests_target_name ${name}.<#= c.tests_directory_name() #>)\n\nset(files \"\")\nfile(GLOB_RECURSE files RELATIVE\n    \"${CMAKE_CURRENT_SOURCE_DIR}/\"\n    \"${CMAKE_CURRENT_SOURCE_DIR}/*.<#= c.implementation_file_extension() #>\")\n\nadd_executable(${tests_target_name} ${files})\n\nset_target_properties(${tests_target_name} PROPERTIES\n<#+\n        if (ast.is_cpp_standard_98()) {\n#>\n    CXX_STANDARD 98\n<#+\n        }\n#>\n    OUTPUT_NAME ${tests_binary_name})\n\n<#+\n        if (ast.is_cpp_standard_98()) {\n#>\ntarget_compile_options(${tests_target_name} PRIVATE\n    $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:\n    -Wno-c99-extensions>)\n<#+\n        }\n#>\n\ntarget_link_libraries(${tests_target_name}\n    ${lib_target_name}\n    ${CMAKE_REQUIRED_LIBRARIES}\n    ${CMAKE_THREAD_LIBS_INIT}\n    ${Boost_LIBRARIES})\n\nset(command $<TARGET_FILE:${tests_target_name}> ${boost_test_parameters})\n\nadd_custom_target(run_${tests_target_name}\n    COMMENT \"Running ${tests_target_name}\" VERBATIM\n    COMMAND ${command}\n    WORKING_DIRECTORY ${stage_bin_dir}\n    DEPENDS ${tests_target_name})\n\nadd_dependencies(run_all_tests run_${tests_target_name})\n\nif(WITH_BENCHMARKS)\n    set(benchmark_file\n        ${benchmark_directory}/${benchmark_prefix}${tests_target_name}.csv)\n    add_custom_target(benchmark_${tests_target_name}\n        COMMENT \"Benchmarking testing ${tests_target_name}\" VERBATIM\n        COMMAND ${benchmark_command} ${benchmark_repeats} ${benchmark_file}\n        ${command}\n        WORKING_DIRECTORY ${stage_bin_dir}\n        DEPENDS ${tests_target_name})\n\n    add_dependencies(benchmark_all benchmark_${tests_target_name})\nendif()\n\nadd_boost_tests(${tests_binary_name} ${files})\n\ninstall(TARGETS ${tests_target_name} RUNTIME DESTINATION bin COMPONENT tests)\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto sn(o.name().simple());\n            const auto qn(ast.get_qualified_name(o.name()));\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= sn #>_generator {\n<#+\n            if (!o.is_parent()) {\n#>\npublic:\n    <#= sn #>_generator();\n\n<#+\n            }\n#>\npublic:\n    typedef <#= qn #> result_type;\n\npublic:\n<#+\n            if (!o.is_immutable())\n#>\n    static void populate(const unsigned int position, result_type& v);\n<#+\n            if (!o.is_parent()) {\n#>\n    static result_type create(const unsigned int position);\n    result_type operator()();\n\nprivate:\n    unsigned int position_;\n<#+\n            }\n#>\npublic:\n    static result_type* create_ptr(const unsigned int position);\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= ye.name().simple() #>_generator {\npublic:\n    <#= ye.name().simple() #>_generator();\n\npublic:\n    typedef <#= ast.get_qualified_name(ye.name()) #> result_type;\n\npublic:\n    static void populate(const unsigned int position, result_type& v);\n    static result_type create(const unsigned int position);\n    result_type operator()();\n\nprivate:\n    unsigned int position_;\n};\n\n<#+\n         } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\nclass <#= sn #>_generator {\npublic:\n    <#= sn #>_generator();\n\npublic:\n    typedef <#= qn #> result_type;\n\npublic:\n<#+\n            if (!p.is_immutable())\n#>\n    static void populate(const unsigned int position, result_type& v);\n    static result_type create(const unsigned int position);\n    result_type operator()();\n\nprivate:\n    unsigned int position_;\n\npublic:\n    static result_type* create_ptr(const unsigned int position);\n};\n\n<#+\n        } // snf\n#>\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto sn(o.name().simple());\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        if (!o.local_attributes().empty()) {\n#>\nnamespace {\n<#+\n        ast.add_helper_methods(o.name().qualified().dot());\n#>\n\n}\n\n<#+\n        }\n\n        {\n            const auto ns(ast.make_namespaces(o.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n            if (!o.is_parent()) {\n#>\n\n<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }\n<#+\n            }\n\n            /*\n             * Populate method.\n             */\n            if (!o.is_immutable()) {\n                bool no_args(o.local_attributes().empty() && o.parents().empty());\n                if (no_args) {\n#>\n\nvoid <#= sn #>_generator::\npopulate(const unsigned int /*position*/, result_type& /*v*/) {\n<#+\n                } else {\n#>\n\nvoid <#= sn #>_generator::\npopulate(const unsigned int position, result_type& v) {\n<#+\n                }\n\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n    <#= pqn #>_generator::populate(position, v);\n<#+\n                }\n                unsigned int i(0);\n                for (const auto& attr : o.local_attributes()) {\n#>\n    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= i #>));\n<#+\n                    ++i;\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Create method.\n             */\n            if (!o.is_parent()) {\n                 const bool no_arg(o.all_attributes().empty());\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::create(const unsigned int<#= (no_arg ? \"/*position*/\" : \" position\") #>) {\n<#+\n                if (o.is_immutable()) {\n#>\n    return <#= sn #>(\n<#+\n                    if (o.local_attributes().empty())\n#>\n\n<#+\n                    else {\n                        utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                        for (const auto& attr : o.local_attributes()) {\n#>\n        create_<#= attr.parsed_type().qualified().identifiable() #>(position + <#= sf.current_position() #>)<#= sf.postfix() #>\n<#+\n                            sf.next();\n                        }\n                    }\n#>\n        );\n<#+\n                } else {\n#>\n    <#= sn #> r;\n<#+\n                    if (!o.all_attributes().empty())\n#>\n    <#= sn #>_generator::populate(position, r);\n    return r;\n<#+\n                }\n#>\n}\n<#+\n            }\n\n            /*\n             * Create method ptr.\n             */\n#>\n\n<#= sn #>_generator::result_type*\n<#= sn #>_generator::create_ptr(const unsigned int position) {\n<#+\n            if (o.leaves().empty()) {\n                if (o.is_immutable())\n#>\n    return new <#= sn #>(create(position));\n<#+\n                else {\n#>\n    <#= sn #>* p = new <#= sn #>();\n    <#= sn #>_generator::populate(position, *p);\n    return p;\n<#+\n                }\n            } else {\n                auto leaves(o.leaves());\n                const auto front(leaves.front());\n                leaves.pop_front();\n                unsigned int i(0);\n                const auto total(static_cast<unsigned int>(leaves.size()));\n                for (const auto& l : leaves) {\n#>\n    if ((position % <#= total #>) == <#= i++ #>)\n        return <#= ast.get_qualified_name(l) #>_generator::create_ptr(position);\n<#+\n                }\n#>\n    return <#= ast.get_qualified_name(front) #>_generator::create_ptr(position);\n<#+\n            }\n#>\n}\n<#+\n            /*\n             * Function operator\n             */\n             if (!o.is_parent()) {\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::operator()() {\n    return create(position_++);\n}\n<#+\n            }\n#>\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::enum_implementation",
      "documentation": "Generates implementation files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/enum_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/enum_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(ye.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n\n<#= ye.name().simple() #>_generator::<#= ye.name().simple() #>_generator() : position_(0) { }\nvoid <#= ye.name().simple() #>_generator::\npopulate(const unsigned int position, result_type& v) {\n    v = static_cast<<#= ye.name().simple() #>>(position % <#= ye.enumerators().size() #>);\n}\n\n<#= ye.name().simple() #>_generator::result_type\n<#= ye.name().simple() #>_generator::create(const unsigned int  position) {\n    result_type r;\n    <#= ye.name().simple() #>_generator::populate(position, r);\n    return r;\n}\n\n<#= ye.name().simple() #>_generator::result_type\n<#= ye.name().simple() #>_generator::operator()() {\n    return create(position_++);\n}\n\n<#+\n         } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::test_data::primitive_implementation",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/test_data/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\nnamespace {\n<#+\n        ast.add_helper_methods(p.name().qualified().dot());\n#>\n\n}\n\n<#+\n        {\n            const auto attr(p.value_attribute());\n            const auto ns(ast.make_namespaces(p.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n            /*\n             * Default constructor.\n             */\n#>\n\n<#= sn #>_generator::<#= sn #>_generator() : position_(0) { }\n<#+\n            /*\n             * Populate method.\n             */\n            if (!p.is_immutable()) {\n#>\n\nvoid <#= sn #>_generator::\npopulate(const unsigned int position, result_type& v) {\n    v.<#= attr.name().simple() #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));\n}\n<#+\n            }\n\n            /*\n             * Create method.\n             */\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::create(const unsigned int position) {\n<#+\n            if (p.is_immutable()) {\n#>\n    return <#= sn #>(create_<#= attr.parsed_type().qualified().identifiable() #>(position + 1));\n<#+\n            } else {\n#>\n    <#= sn #> r;\n    <#= sn #>_generator::populate(position, r);\n    return r;\n<#+\n            }\n#>\n}\n<#+\n            /*\n             * Create method ptr.\n             */\n#>\n\n<#= sn #>_generator::result_type*\n<#= sn #>_generator::create_ptr(const unsigned int position) {\n<#+\n            if (p.is_immutable())\n#>\n    return new <#= sn #>(create(position));\n<#+\n            else {\n#>\n    <#= sn #>* r = new <#= sn #>();\n    <#= sn #>_generator::populate(position, *r);\n    return r;\n<#+\n            }\n#>\n}\n<#+\n            /*\n             * Function operator\n             */\n#>\n\n<#= sn #>_generator::result_type\n<#= sn #>_generator::operator()() {\n    return create(position_++);\n}\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::class_header",
      "documentation": "Generates header files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/class_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/class_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        const auto qn(ast.get_qualified_name(o.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n\n        if (!o.is_parent() && !o.parents().empty()) {\n            const auto& pn(o.parents().front());\n            const auto pqn(ast.get_qualified_name(pn));\n#>\nnamespace boost {\n\ntemplate<>struct\nis_virtual_base_of<\n    <#= pqn #>,\n    <#= qn #>\n> : public mpl::true_ {};\n\n}\n<#+\n        }\n#>\n\nBOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)\n<#+\n        if (o.is_parent()) {\n#>\nBOOST_SERIALIZATION_ASSUME_ABSTRACT(<#= qn #>)\n\n<#+\n        }\n#>\nnamespace boost {\nnamespace serialization {\n\ntemplate<typename Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<typename Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::class_forward_declarations",
      "documentation": "Generates forward declarations for classes.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.object",
        "masd.wale.kvp.archetype.simple_name": "class_forward_declarations",
        "masd.physical.relation_status": "relatable",
        "masd.wale.kvp.meta_element": "object",
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization",
        "masd.physical.postfix": "fwd"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/class_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/class_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_forward_declarations_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class forward declarations\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(o));\n        const auto qn(ast.get_qualified_name(o.name()));\n#>\n\nnamespace boost {\nnamespace serialization {\n\ntemplate<class Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<class Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::primitive_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/primitive_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/primitive_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\nBOOST_SERIALIZATION_SPLIT_FREE(<#= qn #>)\n\nnamespace boost {\nnamespace serialization {\n\ntemplate<typename Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<typename Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::primitive_forward_declarations",
      "documentation": "Generates forward declarations for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.primitive",
        "masd.wale.kvp.archetype.simple_name": "primitive_forward_declarations",
        "masd.physical.relation_status": "relatable",
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization",
        "masd.physical.postfix": "fwd"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/primitive_forward_declarations_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/primitive_forward_declarations_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_forward_declarations_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive forward declarations\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(p));\n        const auto qn(ast.get_qualified_name(p.name()));\n#>\n\nnamespace boost {\nnamespace serialization {\n\ntemplate<class Archive>\nvoid save(Archive& ar, const <#= qn #>& v, unsigned int version);\n\ntemplate<class Archive>\nvoid load(Archive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::type_registrar_header",
      "documentation": "Generates header files for type registrars.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::header_facet_default_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.serialization_type_registrar",
        "masd.wale.kvp.archetype.simple_name": "type_registrar_header",
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/serialization/type_registrar.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/type_registrar_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/type_registrar_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid type_registrar_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"type registrar header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(rg.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto sn(e.name().simple());\n#>\n\nclass <#= sn #> {\npublic:\n\ntemplate<typename Archive>\nstatic void register_types(Archive& ar);\n\n};\n<#+\n        } // snf\n#>\n\n<#+\n\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::class_implementation",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/class_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/class_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        ast.add_helper_methods(o.name().qualified().dot());\n\n        const auto qn(ast.get_qualified_name(o.name()));\n        const bool has_attributes(!o.local_attributes().empty());\n        const bool has_parent(!o.parents().empty());\n        const bool has_attributes_or_parent(has_attributes || has_parent);\n\n        if (o.is_parent() || !o.parents().empty()) {\n#>\n\nBOOST_CLASS_TRACKING(\n    <#= qn #>,\n    boost::serialization::track_selectively)\n<#+\n        }\n#>\n\nnamespace boost {\nnamespace serialization {\n<#+\n\n        /*\n         * Save function\n         */\n#>\n\ntemplate<typename Archive>\nvoid save(Archive& <#= (has_attributes_or_parent ? \"ar\" : \"/*ar*/\") #>,\n    const <#= qn #>& <#= (has_attributes_or_parent ? \"v\" : \"/*v*/\") #>,\n    const unsigned int /*version*/) {\n<#+\n        if (!o.parents().empty()) {\n            const auto& pn(o.parents().front());\n            const auto pqn(ast.get_qualified_name(pn));\n#>\n    ar << make_nvp(\"<#= pn.simple() #>\", base_object<<#= pqn #>>(v));\n<#+\n        }\n\n        if (has_attributes && has_parent)\n#>\n\n<#+\n        for (const auto& attr : o.local_attributes()) {\n#>\n    ar << make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n<#+\n        }\n#>\n}\n\n<#+\n        /*\n         * Load function\n         */\n#>\ntemplate<typename Archive>\nvoid load(Archive& <#= (has_attributes_or_parent ? \"ar,\" : \"/*ar*/,\") #>\n    <#= qn #>& <#= (has_attributes_or_parent ? \"v\" : \"/*v*/\") #>,\n    const unsigned int /*version*/) {\n<#+\n        if (!o.parents().empty()) {\n            const auto& pn(o.parents().front());\n            const auto pqn(ast.get_qualified_name(pn));\n#>\n    ar >> make_nvp(\"<#= pn.simple() #>\", base_object<<#= pqn #>>(v));\n<#+\n            if (has_attributes && has_parent)\n#>\n\n<#+\n        }\n\n        for (const auto& attr : o.local_attributes()) {\n#>\n    ar >> make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n<#+\n        }\n#>\n}\n\n} }\n\nnamespace boost {\nnamespace serialization {\n\ntemplate void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::builtin_header",
      "documentation": "Generates header files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/builtin_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/builtin_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::primitive_implementation",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_implementation_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/primitive_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/primitive_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n\n    const auto sn(p.name().simple());\n    const auto qn(ast.get_qualified_name(p.name()));\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        const auto attr(p.value_attribute());\n#>\n\nnamespace boost {\nnamespace serialization {\n<#+\n\n        /*\n         * Save function\n         */\n#>\n\ntemplate<typename Archive>\nvoid save(Archive& ar, const <#= qn #>& v, const unsigned int /*version*/) {\n    ar << make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n}\n\n<#+\n        /*\n         * Load function\n         */\n#>\ntemplate<typename Archive>\nvoid load(Archive& ar, <#= qn #>& v, const unsigned int /*version*/) {\n    ar >> make_nvp(\"<#= attr.name().simple() #>\", v.<#= attr.member_variable_name() #>);\n}\n\n} }\n\nnamespace boost {\nnamespace serialization {\n\ntemplate void save(archive::polymorphic_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::polymorphic_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::text_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::text_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::binary_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::binary_iarchive& ar, <#= qn #>& v, unsigned int version);\n\ntemplate void save(archive::xml_oarchive& ar, const <#= qn #>& v, unsigned int version);\ntemplate void load(archive::xml_iarchive& ar, <#= qn #>& v, unsigned int version);\n\n} }\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::enum_header",
      "documentation": "Generates header files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, true/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n#>\n\ntemplate<class Archive>\nvoid serialize(Archive& ar, <#= ast.get_qualified_name(ye.name()) #>& v, unsigned int /*version*/){\n    using boost::serialization::make_nvp;\n    ar & make_nvp(\"<#= ye.name().simple() #>\", v);\n}\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::serialization::type_registrar_implementation",
      "documentation": "Generates header files for feature bundles.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::implementation_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.serialization_type_registrar",
        "masd.wale.kvp.archetype.simple_name": "type_registrar_implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.serialization"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::serialization #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/throw_exception.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/serialization/type_registrar.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/type_registrar_implementation_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/serialization/type_registrar_implementation_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid type_registrar_implementation_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n   tracing::scoped_transform_tracer stp(lg, \"type registrar implementation\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& rg(ast.as<logical::entities::serialization::type_registrar>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(rg.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const auto deps(rg.registrar_dependencies());\n            const identification::entities::physical_meta_id carch(\"masd.cpp.types.canonical_archetype\");\n            const auto leaves(ast.names_with_enabled_archetype(carch, rg.leaves()));\n            const bool has_types(!deps.empty() || !leaves.empty());\n            const std::string arg_name(has_types ? \" ar\" : \"\");\n            const auto sn(e.name().simple());\n#>\n\ntemplate<typename Archive>\nvoid <#= sn #>::register_types(Archive&<#= arg_name #>) {\n<#+\n            if (has_types) {\n                for (const auto& d : deps) {\n                    const auto dqn(ast.get_qualified_name(d));\n#>\n    <#= dqn #>::register_types(ar);\n<#+\n                }\n\n                if (!deps.empty() && !leaves.empty())\n#>\n\n<#+\n                for (const auto& l : leaves) {\n                    const auto lqn(ast.get_qualified_name(l));\n#>\n    ar.template register_type<<#= lqn #>>();\n<#+\n                }\n            }\n#>\n}\n\ntemplate void <#= sn #>::register_types(boost::archive::polymorphic_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::polymorphic_iarchive&<#= arg_name #>);\n\ntemplate void <#= sn #>::register_types(boost::archive::text_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::text_iarchive&<#= arg_name #>);\n\ntemplate void <#= sn #>::register_types(boost::archive::binary_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::binary_iarchive&<#= arg_name #>);\n\ntemplate void <#= sn #>::register_types(boost::archive::xml_oarchive&<#= arg_name #>);\ntemplate void <#= sn #>::register_types(boost::archive::xml_iarchive&<#= arg_name #>);\n\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::visual_studio::solution",
      "documentation": "Generates visual studio solutions.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_solution",
        "masd.wale.kvp.archetype.simple_name": "solution",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.containing_namespace": "text.transforms.visual_studio",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "sln"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/solution.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/visual_studio/solution_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/visual_studio/solution_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid solution_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"solution\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::visual_studio::solution;\n    const auto& sln(ast.as<solution>(e));\n#>\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 2012\n<#+\n    for (const auto& ppb : sln.project_persistence_blocks()) {\n#>\nProject(\"{<#= ppb.type_guid() #>}\") = \"<#= ppb.name() #>\", \"<#= ppb.name() #>.csproj\", \"{<#= ppb.guid() #>}\"\nEndProject\n<#+\n    }\n#>\nGlobal\n    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n        Debug|Any CPU = Debug|Any CPU\n        Release|Any CPU = Release|Any CPU\n    EndGlobalSection\n    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n<#+\n    for (const auto& ppb : sln.project_persistence_blocks()) {\n#>\n        {<#= ppb.guid() #>}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n        {<#= ppb.guid() #>}.Debug|Any CPU.Build.0 = Debug|Any CPU\n        {<#= ppb.guid() #>}.Release|Any CPU.ActiveCfg = Release|Any CPU\n        {<#= ppb.guid() #>}.Release|Any CPU.Build.0 = Release|Any CPU\n<#+\n    }\n#>\n    EndGlobalSection\n    GlobalSection(MonoDevelopProperties) = preSolution\n        StartupItem = CppModel.vcxroj\n    EndGlobalSection\nEndGlobal\n<#+\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::visual_studio::msbuild_targets",
      "documentation": "Generates msbuild targets.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_msbuild_targets",
        "masd.wale.kvp.archetype.simple_name": "msbuild_targets",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.containing_namespace": "text.transforms.visual_studio",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "xml"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/msbuild_targets.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/visual_studio/msbuild_targets_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/visual_studio/msbuild_targets_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid msbuild_targets_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"msbuild targets\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::visual_studio::msbuild_targets;\n    const auto& c(ast.as<msbuild_targets>(e));\n\n    {\n        const auto ts(identification::entities::technical_space::xml);\n        ast.make_decoration_preamble(e, ts);\n        const auto model_name(ast.get_identifiable_model_name(c.name()));\n        const auto product_name(ast.get_product_name(c.name()));\n        const auto targets(c.odb_targets());\n#>\n<Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" ToolsVersion=\"4.0\">\n\n    <!--[\n        .NAME: odb.targets\n\n        .SYNOPSIS:\n            Generates all of the ODB files for this project.\n\n        .DESCRIPTION:\n            Calls the ODB compiler against each of the files in this Dogen model that require\n            ODB compilation. Also moves the generated files to their correct location.\n\n        .INPUTS:\n\n        .OUTPUTS:\n    ]-->\n    <Target Name=\"<#= targets.main_target_name() #>\"\n<#+\n            utility::formatters::sequence_formatter sf(targets.targets().size());\n            sf.prefix_configuration().first(\"          DependsOnTargets=\\\"\")\n                                     .not_first(\"                            \");\n            sf.postfix_configuration().last(\"\\\">\");\n            sf.element_separator(\";\");\n            for (const auto& target : targets.targets()) {\n#>\n<#= sf.prefix() #><#= target.name() #><#= sf.postfix() #>\n<#+\n                sf.next();\n            }\n#>\n        <Message Importance=\"high\" Text=\"ODB <#= model_name #> \"/>\n    </Target>\n\n<#+\n            for (const auto& target : targets.targets()) {\n#>\n    <Target Name=\"<#= target.name() #>\">\n        <Message Importance=\"high\" Text=\"<#= target.comment() #>\"/>\n        <Exec WorkingDirectory=\"$(OutputDirectory)\" Command=\"&quot;$(OdbPath)&quot; -D_SECURE_SCL=0 $(OdbIncludeDirectories) --options-file $(MSBuildThisFileDirectory)<#= targets.common_odb_options() #> --options-file $(MSBuildThisFileDirectory)<#= target.object_odb_options() #> --output-dir $(MSBuildThisFileDirectory)<#= target.output_directory() #> $(MSBuildThisFileDirectory)<#= target.types_file() #>\" />\n<#+\n                for (const auto& pair : target.move_parameters()) {\n#>\n        <Move\n            SourceFiles=\"$(MSBuildThisFileDirectory)<#= pair.first #>\"\n            DestinationFolder=\"$(MSBuildThisFileDirectory)<#= pair.second #>\" />\n<#+\n                }\n#>\n    </Target>\n<#+\n            }\n#>\n</Project>\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::visual_studio::project",
      "documentation": "Generates visual studio project.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_project",
        "masd.wale.kvp.archetype.simple_name": "project",
        "masd.physical.part_id": "masd.cpp.project",
        "masd.wale.kvp.containing_namespace": "text.transforms.visual_studio",
        "masd.physical.wale_template_reference": "cpp_artefact_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "xml"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/project.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/visual_studio/project_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/visual_studio/project_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid project_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"project\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::visual_studio::project;\n    const auto& proj(ast.as<project>(e));\n\n#>\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{<#= proj.guid() #>}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <RootNamespace><#= proj.project_name() #></RootNamespace>\n    <AssemblyName><#= proj.project_name() #></AssemblyName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug</OutputPath>\n    <DefineConstants>DEBUG;</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <DebugType>full</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"System\" />\n  </ItemGroup>\n<#+\n        for (const auto& ig : proj.item_groups()) {\n#>\n  <ItemGroup>\n<#+\n            for (const auto& i : ig.items())\n#>\n    <<#= i.name() #> Include=\"<#= i.include() #>\" />\n  </ItemGroup>\n<#+\n        }\n#>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.Cpp.targets\" />\n</Project>\n<#+\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::cpp::lexical_cast::enum_header",
      "documentation": "Generates header files for enumerations.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_header_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.lexical_cast"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::cpp::lexical_cast #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/transformation_error.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/lexical_cast/enum_header_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/cpp/lexical_cast/enum_header_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_header_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum header\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& enm(ast.as<logical::entities::structural::enumeration>(e));\n\n    {\n        auto sbf(ast.make_scoped_boilerplate_formatter(enm));\n        const auto qn(ast.get_qualified_name(enm.name()));\n        const auto sn(enm.name().simple());\n#>\n\nnamespace boost {\n\ntemplate<>\ninline std::string lexical_cast(const <#= qn #>& v) {\n<#+\n        if (!ast.is_cpp_standard_98()) {\n#>\n    using <#= qn #>;\n\n<#+\n        }\n#>\n    switch (v) {\n<#+\n        for (const auto& enu : enm.enumerators()) {\n            const auto enu_sn(enu.name().simple());\n            std::string enu_qn;\n            if (ast.is_cpp_standard_98())\n                enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n            else\n                enu_qn = sn + \"::\" + enu_sn;\n#>\n    case <#= enu_qn #>:\n        return \"<#= sn + \"::\" + enu_sn #>\";\n<#+\n        }\n#>\n    default:\n        throw boost::bad_lexical_cast();\n    }\n}\n\ntemplate<>\ninline <#= qn #> lexical_cast(const std::string & s) {\n<#+\n        if (!ast.is_cpp_standard_98()) {\n#>\n    using <#= qn #>;\n\n<#+\n        }\n\n        for (const auto& enu : enm.enumerators()) {\n           const auto enu_sn(enu.name().simple());\n           std::string enu_qn;\n           if (ast.is_cpp_standard_98())\n               enu_qn = ast.get_qualified_namespace(enm.name()) + \"::\" + enu_sn;\n           else\n               enu_qn = sn + \"::\" + enu_sn;\n#>\n    if (s == \"<#= enu_sn #>\" || s == \"<#= sn + \"::\" + enu_sn #>\")\n        return <#= enu_qn #>;\n<#+\n        }\n#>\n    throw boost::bad_lexical_cast();\n}\n\n}\n\n<#+\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::types::class",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/class_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/class_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    const auto id(e.name().qualified().dot());\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n            if (!o.in_inheritance_relationship() || !o.is_child()) {\n#>\n    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #>\n<#+\n            } else {\n                const auto& pn(o.parents().front());\n                const auto pqn(ast.get_qualified_name(pn));\n#>\n    public <#= ast.make_inheritance_keyword_text(o) #>class <#= sn #> : <#= pqn #>\n<#+\n            }\n#>\n    {\n<#+\n            if (!o.local_attributes().empty()) {\n                if (!o.helper_properties().empty())\n                    ast.add_helper_methods(id);\n\n                /*\n                * Properties\n                */\n#>\n        #region Properties\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    ast.comment(attr.documentation(), 2/*indent*/);\n#>\n        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (o.is_immutable() ? \"internal \" : \"\") #>set; }\n<#+\n                }\n#>\n        #endregion\n\n<#+\n            }\n\n            /*\n             * Constructors.\n             */\n#>\n        #region Constructors\n        public <#= sn #>() { }\n<#+\n            if (!o.all_attributes().empty()) {\n                const auto attr_count(o.all_attributes().size());\n                if (attr_count == 1) {\n                     const auto attr(*o.all_attributes().begin());\n#>\n        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)\n<#+\n                } else {\n#>\n\n        public <#= sn #>(\n<#+\n                    utility::formatters::sequence_formatter sf(attr_count);\n                    sf.postfix_configuration().last(\")\");\n                    for (const auto& attr : o.all_attributes()) {\n#>\n            <#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #><#= sf.postfix() #>\n<#+\n                        sf.next();\n                    }\n                }\n\n                if (!o.parents().empty()) {\n                    const auto& pair(*o.inherited_attributes().begin());\n                    const auto& pattrs(pair.second);\n                    const auto size(pattrs.size());\n\n                    if (size == 0) {\n#>\n            : base()\n<#+\n                    } else if (size == 1) {\n#>\n            : base(<#= ast.make_argument_name(pattrs.front()) #>)\n<#+\n                    } else {\n                        utility::formatters::sequence_formatter sf(size);\n                        sf.postfix_configuration().last(\")\");\n                        sf.prefix_configuration().first(\",\").not_first(\",\");\n#>\n            : base(\n<#+\n                        for (const auto& pattr : pattrs) {\n#>\n                <#= ast.make_argument_name(pattr) #><#= sf.postfix() #>\n<#+\n                            sf.next();\n                        }\n                    }\n                }\n#>\n        {\n<#+\n                if (o.local_attributes().empty()) {\n#>\n            // no properties\n<#+\n                } else {\n                    for (const auto& attr : o.local_attributes()) {\n#>\n            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;\n<#+\n                    }\n                }\n#>\n        }\n<#+\n            }\n#>\n        #endregion\n\n<#+\n            /*\n             * Equals\n             */\n#>\n        #region Equality\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != GetType()) return false;\n\n            var value = obj as <#= sn #>;\n<#+\n            if (o.local_attributes().empty()) {\n                if (!o.parents().empty()) {\n#>\n            return (value != null && base.Equals(value));\n<#+\n                } else {\n#>\n            return value != null;\n<#+\n                }\n            } else {\n                if (!o.parents().empty()) {\n#>\n            if (value == null || !base.Equals(value)) return false;\n<#+\n                } else {\n#>\n            if (value == null) return false;\n<#+\n                }\n#>\n\n            return\n<#+\n                utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                sf.element_separator(\"\");\n                sf.postfix_configuration().not_last(\" &&\");\n                sf.postfix_configuration().last(\";\");\n                for (const auto& attr : o.local_attributes()) {\n                    if (attr.parsed_type().is_current_simple_type()) {\n                        if (attr.parsed_type().is_floating_point()) {\n#>\n                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                        } else {\n#>\n                <#= attr.name().simple() #> == value.<#= attr.name().simple() #><#= sf.postfix() #>\n<#+\n                        }\n                    } else {\n#>\n                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&\n                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>)<#= sf.postfix() #>\n<#+\n                    }\n                    sf.next();\n                }\n            }\n#>\n        }\n\n        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            if (Object.ReferenceEquals(lhs, rhs))\n                return true;\n\n            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            return !(lhs == rhs);\n        }\n\n        public override int GetHashCode()\n        {\n<#+\n            if (o.local_attributes().empty()) {\n#>\n            return 0;\n<#+\n            } else {\n#>\n            unchecked\n            {\n                // Choose large primes to avoid hashing collisions\n                const int HashingBase = (int) 2166136261;\n                const int HashingMultiplier = 16777619;\n\n                int hash = HashingBase;\n<#+\n                for (const auto& attr : o.local_attributes()) {\n                    if (attr.parsed_type().is_current_simple_type()) {\n#>\n                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();\n<#+\n                    } else {\n#>\n                hash = (hash * HashingMultiplier) ^\n                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);\n<#+\n                    }\n                }\n#>\n                return hash;\n            }\n<#+\n            }\n#>\n        }\n        #endregion\n<#+\n            if (o.in_inheritance_relationship())\n            {\n#>\n\n        #region Dumpers\n<#+\n                if (o.is_parent() && !o.is_child()) {\n#>\n        internal abstract string Dump();\n<#+\n                } else if (o.is_leaf()) {\n#>\n        internal override string Dump()\n        {\n            return <#= sn #>Dumper.Dump(this);\n        }\n<#+\n                }\n#>\n        #endregion\n<#+\n        }\n#>\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::types::exception",
      "documentation": "Generates implementation files for exceptions.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::exception_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/exception.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/exception_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/exception_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid exception_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"exception\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n#>\n    public class <#= sn #>  : Exception\n    {\n        public <#= sn #>() { }\n        public <#= sn #>(string message) : base(message) { }\n        public <#= sn #>(string message, Exception inner) : base(message, inner) { }\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::types::builtin",
      "documentation": "Generates implementation files for builtins.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::builtin_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/builtin.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/builtin_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/builtin_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid builtin_transform::\napply(const text::transforms::context& ctx, const text::entities::model& /*lps*/,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"builtin\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    stp.end_transform(a);\n}\n\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::types::enum",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/enum_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/enum_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n            if (ye.use_implementation_defined_underlying_element())\n#>\n    public enum <#= sn #>\n<#+\n            else\n#>\n    public enum <#= sn #> : <#= ast.get_qualified_name(ye.underlying_element()) #>\n    {\n<#+\n            utility::formatters::sequence_formatter sf(ye.enumerators().size());\n            for (const auto& en : ye.enumerators()) {\n                if (ye.use_implementation_defined_enumerator_values())\n#>\n        <#= en.name().simple() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                else\n#>\n        <#= en.name().simple() #> = <#= en.value() #><#= sf.postfix() #><#= ast.comment_inline(en.documentation()) #>\n<#+\n                sf.next();\n            }\n#>\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::types::primitive",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.types"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::types #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<iostream> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/primitive_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/types/primitive_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    const auto id(e.name().qualified().dot());\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            ast.comment(e.documentation(), 1/*indent*/);\n#>\n    public sealed class <#= sn #>\n    {\n<#+\n            if (!p.helper_properties().empty())\n                ast.add_helper_methods(id);\n\n            /*\n             * Properties\n             */\n#>\n        #region Properties\n<#+\n            const auto& attr(p.value_attribute());\n            ast.comment(attr.documentation(), 2/*indent*/);\n#>\n        public <#= ast.get_qualified_name(attr.parsed_type()) #> <#= attr.name().simple() #> { get; <#= (p.is_immutable() ? \"internal \" : \"\") #>set; }\n        #endregion\n\n<#+\n            /*\n             * Constructors.\n             */\n#>\n        #region Constructors\n        public <#= sn #>() { }\n        public <#= sn #>(<#= ast.get_qualified_name(attr.parsed_type()) #> <#= ast.make_argument_name(attr) #>)\n        {\n            <#= attr.name().simple() #> = <#= ast.make_argument_name(attr) #>;\n        }\n        #endregion\n\n<#+\n            /*\n             * Equals\n             */\n#>\n        #region Equality\n        public override bool Equals(object obj)\n        {\n            if (ReferenceEquals(null, obj)) return false;\n            if (ReferenceEquals(this, obj)) return true;\n            if (obj.GetType() != GetType()) return false;\n\n            var value = obj as <#= sn #>;\n            if (value == null) return false;\n            return\n<#+\n             if (attr.parsed_type().is_current_simple_type()) {\n                if (attr.parsed_type().is_floating_point()) {\n#>\n                NearlyEqual(<#= attr.name().simple() #>, value.<#= attr.name().simple() #>);\n<#+\n                } else {\n#>\n                <#= attr.name().simple() #> == value.<#= attr.name().simple() #>;\n<#+\n                }\n           } else {\n#>\n                <#= attr.name().simple() #> != null && value.<#= attr.name().simple() #> != null &&\n                <#= attr.name().simple() #>.Equals(value.<#= attr.name().simple() #>);\n<#+\n            }\n#>\n        }\n\n        public static bool operator ==(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            if (Object.ReferenceEquals(lhs, rhs))\n                return true;\n\n            return !Object.ReferenceEquals(null, lhs) && lhs.Equals(rhs);\n        }\n\n        public static bool operator !=(<#= sn #> lhs, <#= sn #> rhs)\n        {\n            return !(lhs == rhs);\n        }\n\n        public override int GetHashCode()\n        {\n            unchecked\n            {\n                // Choose large primes to avoid hashing collisions\n                const int HashingBase = (int) 2166136261;\n                const int HashingMultiplier = 16777619;\n\n                int hash = HashingBase;\n<#+\n                if (attr.parsed_type().is_current_simple_type()) {\n#>\n                hash = (hash * HashingMultiplier) ^ <#= attr.name().simple() #>.GetHashCode();\n<#+\n                } else {\n#>\n                hash = (hash * HashingMultiplier) ^\n                    (!<#= ast.reference_equals(attr) #>.ReferenceEquals(null, <#= attr.name().simple() #>) ? <#= attr.name().simple() #>.GetHashCode() : 0);\n<#+\n                }\n#>\n                return hash;\n            }\n        }\n        #endregion\n    }\n<#+\n        } // snf\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::io::class",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/class_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/class_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"class\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const bool has_attributes(!o.local_attributes().empty());\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            if (value == null)\n            {\n                assistant.Add(\"data\", \"<null>\");\n                assistant.AddEndObject();\n                return;\n            }\n\n            assistant.AddKey(\"data\");\n            assistant.AddPairSeparator();\n            assistant.AddStartObject();\n<#+\n                if (!o.parents().empty()) {\n                    const auto& pn(o.parents().front());\n                    const auto pqn(ast.get_qualified_name(pn));\n#>\n            assistant.AddKey(\"__parent_0__\");\n            assistant.AddPairSeparator();\n            <#= pqn #>Dumper.Dump(assistant, value<#= (has_attributes ? \", true/*withSeparator*/\" : \"\") #>);\n<#+\n                }\n\n                utility::formatters::sequence_formatter sf(o.local_attributes().size());\n                sf.element_separator(\"\");\n                sf.postfix_configuration().not_last(\", true/*withSeparator*/\");\n                sf.postfix_configuration().last(\"\");\n\n                for (const auto& attr : o.local_attributes()) {\n                    const auto oap(ast.get_assistant_properties(attr));\n                    if (oap && oap->requires_assistance()) {\n#>\n            assistant.Add(\"<#= attr.name().simple() #>\", value.<#= attr.name().simple() #><#= sf.postfix() #>);\n<#+\n                    } else {\n                        const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            assistant.AddKey(\"<#= attr.name().simple() #>\");\n            assistant.AddPairSeparator();\n            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #><#= sf.postfix() #>);\n<#+\n                    }\n\n                    sf.next();\n                }\n#>\n            assistant.AddEndObject(); // data\n            assistant.AddEndObject(); // main object\n            assistant.HandleMemberSeparator(withSeparator);\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n<#+\n                if (o.is_parent()) {\n#>\n            return value.Dump();\n<#+\n                } else {\n#>\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n<#+\n                }\n#>\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::io::enum",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/enum_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/enum_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n   tracing::scoped_transform_tracer stp(lg, \"enum\",\n       transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            string valueAsString = \"Unsupported Value\";\n            switch (value)\n            {\n<#+\n            for (const auto& en : ye.enumerators()) {\n#>\n                case <#= ye.name().simple() #>.<#= en.name().simple() #>:\n                    valueAsString = \"<#= en.name().simple() #>\";\n                    break;\n<#+\n            }\n#>\n            }\n\n            assistant.Add(\"value\", valueAsString);\n            assistant.AddEndObject();\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::io::primitive",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.csharp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/primitive_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/primitive_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>Dumper\n    {\n        static internal void Dump(AssistantDumper assistant, <#= sn #> value, bool withSeparator = false)\n        {\n            assistant.IncrementDepth();\n            if (assistant.MaximumDepthExceeded())\n                return;\n\n            assistant.AddStartObject();\n            assistant.AddType(\"<#= qn #>\", true/*withSeparator*/);\n            if (value == null)\n            {\n                assistant.Add(\"data\", \"<null>\");\n                assistant.AddEndObject();\n                return;\n            }\n\n            assistant.AddKey(\"data\");\n            assistant.AddPairSeparator();\n            assistant.AddStartObject();\n<#+\n            const auto attr(p.value_attribute());\n            const auto oap(ast.get_assistant_properties(attr));\n            if (oap && oap->requires_assistance()) {\n#>\n            assistant.Add(\"<#= attr.name().simple() #>\", value.<#= attr.name().simple() #>);\n<#+\n            } else {\n                const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            assistant.AddKey(\"<#= attr.name().simple() #>\");\n            assistant.AddPairSeparator();\n            <#= attr_qn #>Dumper.Dump(assistant, value.<#= attr.name().simple() #>;\n<#+\n            }\n#>\n            assistant.AddEndObject(); // data\n            assistant.AddEndObject(); // main object\n            assistant.HandleMemberSeparator(withSeparator);\n\n            assistant.DecrementDepth();\n        }\n\n        public static string Dump(<#= sn #> value)\n        {\n            var assistant = new AssistantDumper();\n            Dump(assistant, value);\n            return assistant.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::io::assistant",
      "documentation": "Generates implementation files for assistants.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::archetype_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.assistant",
        "masd.wale.kvp.archetype.simple_name": "assistant",
        "masd.wale.kvp.containing_namespace": "text.csharp.transforms.io"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::io #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/assistant_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/io/assistant_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid assistant_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"assistant\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Text;\nusing System.Collections;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    class <#= sn #>Dumper\n    {\n        #region Properties\n        private readonly StringBuilder _stringBuilder;\n        private int _currentDepth;\n\n        private const uint MaxDepth = 1000;\n        private const string HashCode = \"HashCode\";\n        private const string Type = \"__type__\";\n        private const string StringType = \"string\";\n        private const string ByteType = \"byte\";\n        private const string SByteType = \"sbyte\";\n        private const string IntType = \"int\";\n        private const string UIntType = \"uint\";\n        private const string LongType = \"long\";\n        private const string ULongType = \"ulong\";\n        private const string FloatType = \"float\";\n        private const string DoubleType = \"double\";\n        private const string CharType = \"char\";\n        private const string DecimalType = \"decimal\";\n        private const string BoolType = \"bool\";\n        private const string NullValue = \"<null>\";\n        private const string SystemObjectType = \"System.Object\";\n        private const string KeyType = \"key\";\n        private const string ValueType = \"value\";\n        private const string DataKey = \"data\";\n        #endregion\n\n        #region Depth management\n        public void IncrementDepth()\n        {\n            ++_currentDepth;\n        }\n\n        public void DecrementDepth()\n        {\n            ++_currentDepth;\n        }\n\n        public bool MaximumDepthExceeded()\n        {\n            return _currentDepth > MaxDepth;\n        }\n        #endregion\n\n        #region Adds for JSON syntax\n        public void AddStartObject()\n        {\n            _stringBuilder.Append(\"{ \");\n        }\n\n        public void AddEndObject()\n        {\n            _stringBuilder.Append(\" }\");\n        }\n\n        public void AddStartArray()\n        {\n            _stringBuilder.Append(\"[ \");\n        }\n\n        public void AddEndArray()\n        {\n            _stringBuilder.Append(\" ]\");\n        }\n\n        public void AddPairSeparator()\n        {\n            _stringBuilder.Append(\" : \");\n        }\n\n        public void AddMemberSeparator()\n        {\n            _stringBuilder.Append(\", \");\n        }\n\n        public void AddQuoted(string value)\n        {\n            if (value == null)\n                _stringBuilder.Append(\"\\\"<null>\\\"\");\n            else\n                _stringBuilder.Append(\"\\\"\" + value + \"\\\"\");\n        }\n\n        public void AddNonQuoted(int value)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n        }\n\n        public void AddKey(string k)\n        {\n            AddQuoted(k);\n        }\n\n        public void AddType(string typeName, bool withSeparator = false)\n        {\n            AddKey(Type);\n            AddPairSeparator();\n            AddQuoted(typeName);\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddKeyWithSeparator(string key)\n        {\n            AddKey(key);\n            AddPairSeparator();\n        }\n\n        public void HandleMemberSeparator(bool withSeparator)\n        {\n            if (withSeparator)\n                AddMemberSeparator();\n        }\n        #endregion\n\n        #region Add value for well known types\n        private bool HandleBoxedPrimitives(object value)\n        {\n            var type = value.GetType();\n            if (type == typeof(string))\n            {\n                AddStartObject();\n                AddType(StringType, true/*withSeparator*/);\n                Add(DataKey, value as string);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(byte))\n            {\n                AddStartObject();\n                AddType(ByteType, true/*withSeparator*/);\n                Add(DataKey, (byte)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(sbyte))\n            {\n                AddStartObject();\n                AddType(SByteType, true/*withSeparator*/);\n                Add(DataKey, (sbyte)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(int))\n            {\n                AddStartObject();\n                AddType(IntType, true/*withSeparator*/);\n                Add(DataKey, (int)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(uint))\n            {\n                AddStartObject();\n                AddType(UIntType, true/*withSeparator*/);\n                Add(DataKey, (uint)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(long))\n            {\n                AddStartObject();\n                AddType(LongType, true/*withSeparator*/);\n                Add(DataKey, (long)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(ulong))\n            {\n                AddStartObject();\n                AddType(ULongType, true/*withSeparator*/);\n                Add(DataKey, (ulong)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(float))\n            {\n                AddStartObject();\n                AddType(FloatType, true/*withSeparator*/);\n                Add(DataKey, (float)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(double))\n            {\n                AddStartObject();\n                AddType(DoubleType, true/*withSeparator*/);\n                Add(DataKey, (double)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(char))\n            {\n                AddStartObject();\n                AddType(CharType, true/*withSeparator*/);\n                Add(DataKey, (char)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(decimal))\n            {\n                AddStartObject();\n                AddType(DecimalType, true/*withSeparator*/);\n                Add(DataKey, (decimal)value);\n                AddEndObject();\n                return true;\n            }\n\n            if (type == typeof(bool))\n            {\n                AddStartObject();\n                AddType(BoolType, true/*withSeparator*/);\n                Add(DataKey, (bool)value);\n                AddEndObject();\n                return true;\n            }\n\n            return false;\n        }\n\n        private void AddValue(object value, bool withSeparator = false)\n        {\n            AddStartObject();\n            AddType(SystemObjectType, true/*withSeparator*/);\n\n            if (value == null)\n            {\n                Add(DataKey, NullValue);\n                AddEndObject();\n                HandleMemberSeparator(withSeparator);\n                return;\n            }\n\n            AddKey(DataKey);\n            AddPairSeparator();\n            if (HandleBoxedPrimitives(value))\n            {\n                AddEndObject();\n                HandleMemberSeparator(withSeparator);\n                return;\n            }\n\n            AddStartObject();\n            AddKey(HashCode);\n            AddPairSeparator();\n            AddNonQuoted(value.GetHashCode());\n\n            AddEndObject(); // data\n            AddEndObject();\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(string value, bool withSeparator = false)\n        {\n            AddQuoted(value);\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(byte value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(sbyte value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(int value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(uint value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(long value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(ulong value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(float value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(double value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(char value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(Convert.ToInt16(value)));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(decimal value, bool withSeparator = false)\n        {\n            _stringBuilder.Append(Convert.ToString(value));\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(bool value, bool withSeparator = false)\n        {\n            if (value)\n                _stringBuilder.Append(\"true\");\n            else\n                _stringBuilder.Append(\"false\");\n\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(IEnumerable value, bool withSeparator = false)\n        {\n            AddStartArray();\n            bool isFirst = true;\n            foreach (var item in value)\n            {\n                if (!isFirst)\n                    AddMemberSeparator();\n\n                AddValue(item);\n                isFirst = false;\n            }\n            AddEndArray();\n            HandleMemberSeparator(withSeparator);\n        }\n\n        private void AddValue(IDictionary value, bool withSeparator = false)\n        {\n            AddStartArray();\n            bool isFirst = true;\n            foreach (DictionaryEntry item in value)\n            {\n                if (!isFirst)\n                    AddMemberSeparator();\n\n                AddStartArray();\n\n                AddStartObject();\n                AddType(KeyType, true/*withSeparator*/);\n                Add(DataKey, item.Key);\n                AddEndObject();\n\n                AddMemberSeparator();\n\n                AddStartObject();\n                AddType(ValueType, true/*withSeparator*/);\n                Add(DataKey, item.Value);\n                AddEndObject();\n\n                AddEndArray();\n                isFirst = false;\n            }\n            AddEndArray();\n            HandleMemberSeparator(withSeparator);\n        }\n        #endregion\n\n        #region Add for well known types\n        public void Add(string key, object value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, string value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, byte value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, sbyte value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, int value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, uint value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, long value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, ulong value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, float value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, double value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, char value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, decimal value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, bool value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, IEnumerable value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n\n        public void Add(string key, IDictionary value, bool withSeparator = false)\n        {\n            AddKeyWithSeparator(key);\n            AddValue(value, withSeparator);\n        }\n        #endregion\n\n        public AssistantDumper()\n        {\n            _stringBuilder = new StringBuilder();\n        }\n\n        public override string ToString()\n        {\n            return _stringBuilder.ToString();\n        }\n    }\n<#+\n        }\n    } // sbf\n\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::test_data::class",
      "documentation": "Generates implementation files for objects.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::object_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/object.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/class_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/class_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid class_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"FIXME\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& o(ast.as<logical::entities::structural::object>(e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n            const bool has_attributes(!o.all_attributes().empty());\n            const bool is_parent_or_has_attributes(\n                !o.parents().empty() || has_attributes);\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>SequenceGenerator\n    {\n        static internal void Populate(<#= sn #> value, uint position)\n        {\n<#+\n                if (!is_parent_or_has_attributes) {\n#>\n            // nothing to populate\n<#+\n                } else {\n                    unsigned int count(0);\n                    if (!o.parents().empty()) {\n                        const auto& pn(o.parents().front());\n                        const auto pqn(ast.get_qualified_name(pn));\n#>\n            <#= pqn #>SequenceGenerator.Populate(value, position);\n<#+\n                    }\n\n                    for (const auto& attr : o.local_attributes()) {\n                        const auto oap(ast.get_assistant_properties(attr));\n                        if (oap && oap->requires_assistance()) {\n#>\n            value.<#= attr.name().simple() #> = AssistantSequenceGenerator.Create<#= oap->method_postfix() #>(position + <#= count++ #>);\n<#+\n                        } else {\n                            const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            value.<#= attr.name().simple() #> = <#= attr_qn #>SequenceGenerator.Create(position + <#= count++ #>);\n<#+\n                        }\n                    }\n                }\n#>\n        }\n\n        static internal <#= sn #> Create(uint position)\n        {\n<#+\n            if (!o.is_parent()) {\n#>\n            var result = new <#= sn #>();\n<#+\n                if (has_attributes) {\n#>\n            Populate(result, position);\n<#+\n                }\n#>\n            return result;\n<#+\n            } else {\n                auto leaves(o.leaves());\n                const auto front(leaves.front());\n                leaves.pop_front();\n                unsigned int i(0);\n                const auto total(static_cast<unsigned int>(leaves.size()));\n                for (const auto& l : leaves) {\n#>\n            if ((position % <#= total #>) == <#= i++ #>)\n                return <#= ast.get_qualified_name(l) #>SequenceGenerator.Create(position);\n<#+\n                }\n#>\n            return <#= ast.get_qualified_name(front) #>SequenceGenerator.Create(position);\n<#+\n            }\n#>\n        }\n\n        #region Enumerator\n        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable\n        {\n            #region Properties\n            private uint _position;\n            private <#= sn #> _current;\n            #endregion\n\n            private void PopulateCurrent()\n            {\n                _current = <#= sn #>SequenceGenerator.Create(_position);\n            }\n\n            #region IDisposable\n            public void Dispose()\n            {\n            }\n            #endregion\n\n            #region IEnumerator implementation\n            public bool MoveNext()\n            {\n                ++_position;\n                PopulateCurrent();\n                return true;\n            }\n\n            public void Reset()\n            {\n                _position = 0;\n                PopulateCurrent();\n            }\n\n            public object Current {\n                get\n                {\n                    return _current;\n                }\n            }\n\n            <#= sn #> IEnumerator<<#= sn #>>.Current\n            {\n                get\n                {\n                    return _current;\n                }\n            }\n            #endregion\n\n            public <#= sn #>Enumerator()\n            {\n                PopulateCurrent();\n            }\n        }\n        #endregion\n\n        #region Enumerable\n        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>\n        {\n            #region IEnumerable implementation\n            public IEnumerator GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n\n            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n            #endregion\n        }\n        #endregion\n\n        static public IEnumerable<<#= sn #>> Sequence()\n        {\n            return new <#= sn #>Enumerable();\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::test_data::assistant",
      "documentation": "Generates implementation files for assistants.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::archetype_configuration"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.assistant",
        "masd.wale.kvp.archetype.simple_name": "assistant",
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/assistant_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/assistant_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid assistant_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"assistant\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Specialized;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Provides helper methods for the sequence generators.\n    /// </summary>\n    static class <#= sn #>SequenceGenerator\n    {\n        private const int SequenceSize = 10;\n\n        public static object CreateObject(uint position)\n        {\n            return \"this is an object: \" + Convert.ToString(position);\n        }\n\n        public static string CreateString(uint position)\n        {\n            return \"this is a string: \" + Convert.ToString(position);\n        }\n\n        public static byte CreateByte(uint position)\n        {\n            return Convert.ToByte(position);\n        }\n\n        public static sbyte CreateShortByte(uint position)\n        {\n            return Convert.ToSByte(position);\n        }\n\n        public static int CreateInt(uint position)\n        {\n            return Convert.ToInt32(position);\n        }\n\n        public static uint CreateUInt(uint position)\n        {\n            return position;\n        }\n\n        public static short CreateShort(uint position)\n        {\n            return Convert.ToInt16(position);\n        }\n\n        public static ushort CreateUShort(uint position)\n        {\n            return Convert.ToUInt16(position);\n        }\n\n        public static long CreateLong(uint position)\n        {\n            return Convert.ToInt64(position);\n        }\n\n        public static ulong CreateULong(uint position)\n        {\n            return Convert.ToUInt64(position);\n        }\n\n        public static float CreateFloat(uint position)\n        {\n            return Convert.ToSingle(position);\n        }\n\n        public static double CreateDouble(uint position)\n        {\n            return Convert.ToDouble(position);\n        }\n\n        public static char CreateChar(uint position)\n        {\n            return Convert.ToChar(position);\n        }\n\n        public static bool CreateBool(uint position)\n        {\n            return position % 2 == 0;\n        }\n\n        public static decimal CreateDecimal(uint position)\n        {\n            return Convert.ToDecimal(position);\n        }\n\n        public static IEnumerable CreateIEnumerable(uint position)\n        {\n            return CreateArrayList(position);\n        }\n\n        public static ICollection CreateICollection(uint position)\n        {\n            return CreateArrayList(position);\n        }\n\n        public static IList CreateIList(uint position)\n        {\n            return CreateArrayList(position);\n        }\n\n        public static ArrayList CreateArrayList(uint position)\n        {\n            var result = new ArrayList();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                switch((position + i) % 5)\n                {\n                case 0: result.Add(CreateString(position + i)); break;\n                case 1: result.Add(CreateByte(position + i)); break;\n                case 2: result.Add(CreateInt(position + i)); break;\n                case 3: result.Add(CreateLong(position + i)); break;\n                case 4: result.Add(CreateFloat(position + i)); break;\n                case 5: result.Add(CreateDecimal(position + i)); break;\n                default: result.Add(CreateBool(position + i)); break;\n                }\n            }\n            return result;\n        }\n\n        public static IDictionary CreateIDictionary(uint position)\n        {\n            return CreateHashtable(position);\n        }\n\n        public static Hashtable CreateHashtable(uint position)\n        {\n            var result = new Hashtable();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static HybridDictionary CreateHybridDictionary(uint position)\n        {\n            var result = new HybridDictionary();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static NameValueCollection CreateNameValueCollection(uint position)\n        {\n            var result = new NameValueCollection();\n            for (uint i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static BitArray CreateBitArray(uint position)\n        {\n            var result = new BitArray(SequenceSize);\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result[i] = position % 2 == 0;\n            }\n            return result;\n        }\n\n        public static Queue CreateQueue(uint position)\n        {\n            var result = new Queue();\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result.Enqueue(\"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static Stack CreateStack(uint position)\n        {\n            var result = new Stack();\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result.Push(\"value_\" + position + i);\n            }\n            return result;\n        }\n\n        public static SortedList CreateSortedList(uint position)\n        {\n            var result = new SortedList();\n            for (int i = 0; i < SequenceSize; i++)\n            {\n                result.Add(\"key_\" + position + i, \"value_\" + position + i);\n            }\n            return result;\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::test_data::enum",
      "documentation": "Generates implementation files for enums.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::enumeration_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/enumeration.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/enum_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/enum_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid enum_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"enum\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& ye(ast.as<logical::entities::structural::enumeration>(e));\n    {\n        const auto sn(e.name().simple());\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>SequenceGenerator\n    {\n        static internal <#= sn #> Create(uint position)\n        {\n            var result = (<#= sn #>)(position % <#= ye.enumerators().size() #>);\n            return result;\n        }\n\n        #region Enumerator\n        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable\n        {\n            #region Properties\n            private uint _position;\n            private <#= sn #> _current;\n            #endregion\n\n            private void PopulateCurrent()\n            {\n                _current = <#= sn #>SequenceGenerator.Create(_position);\n            }\n\n            #region IDisposable\n            public void Dispose()\n            {\n            }\n            #endregion\n\n            #region IEnumerator implementation\n            public bool MoveNext()\n            {\n                ++_position;\n                PopulateCurrent();\n                return true;\n            }\n\n            public void Reset()\n            {\n                _position = 0;\n                PopulateCurrent();\n            }\n\n            public object Current {\n                get\n                {\n                    return _current;\n                }\n            }\n\n            <#= sn #> IEnumerator<<#= sn #>>.Current\n            {\n                get\n                {\n                    return _current;\n                }\n            }\n            #endregion\n\n            public <#= sn #>Enumerator()\n            {\n                PopulateCurrent();\n            }\n        }\n        #endregion\n\n        #region Enumerable\n        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>\n        {\n            #region IEnumerable implementation\n            public IEnumerator GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n\n            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n            #endregion\n        }\n        #endregion\n\n        static public IEnumerable<<#= sn #>> Sequence()\n        {\n            return new <#= sn #>Enumerable();\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::test_data::primitive",
      "documentation": "Generates implementation files for primitives.\n",
      "stereotypes": [
        "masd::physical::archetype",
        "dogen::primitive_configuration"
      ],
      "tagged_values": {
        "masd.wale.kvp.containing_namespace": "text.transforms.test_data"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::test_data #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/structural/primitive.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/primitive_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/test_data/primitive_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid primitive_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"primitive\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    const auto& p(ast.as<logical::entities::structural::primitive>(e));\n    {\n        const auto sn(e.name().simple());\n        const auto qn(ast.get_qualified_name(e.name()));\n        auto sbf(ast.make_scoped_boilerplate_formatter(e));\n        {\n#>\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\n\n<#+\n            const auto ns(ast.make_namespaces(e.name()));\n            auto snf(ast.make_scoped_namespace_formatter(ns));\n\n#>\n    /// <summary>\n    /// Generates sequences of <#= sn #>.\n    /// </summary>\n    public static class <#= sn #>SequenceGenerator\n    {\n        static internal void Populate(<#= sn #> value, uint position)\n        {\n<#+\n            const auto attr(p.value_attribute());\n            const auto oap(ast.get_assistant_properties(attr));\n            if (oap && oap->requires_assistance()) {\n#>\n            value.<#= attr.name().simple() #> = AssistantSequenceGenerator.Create<#= oap->method_postfix() #>(position);\n<#+\n            } else {\n                const auto attr_qn(ast.get_qualified_name(attr.parsed_type().current()));\n#>\n            value.<#= attr.name().simple() #> = <#= attr_qn #>SequenceGenerator.Create(position);\n<#+\n            }\n#>\n        }\n\n        static internal <#= sn #> Create(uint position)\n        {\n            var result = new <#= sn #>();\n            Populate(result, position);\n            return result;\n        }\n\n        #region Enumerator\n        private class <#= sn #>Enumerator : IEnumerator, IEnumerator<<#= sn #>>, IDisposable\n        {\n            #region Properties\n            private uint _position;\n            private <#= sn #> _current;\n            #endregion\n\n            private void PopulateCurrent()\n            {\n                _current = <#= sn #>SequenceGenerator.Create(_position);\n            }\n\n            #region IDisposable\n            public void Dispose()\n            {\n            }\n            #endregion\n\n            #region IEnumerator implementation\n            public bool MoveNext()\n            {\n                ++_position;\n                PopulateCurrent();\n                return true;\n            }\n\n            public void Reset()\n            {\n                _position = 0;\n                PopulateCurrent();\n            }\n\n            public object Current {\n                get\n                {\n                    return _current;\n                }\n            }\n\n            <#= sn #> IEnumerator<<#= sn #>>.Current\n            {\n                get\n                {\n                    return _current;\n                }\n            }\n            #endregion\n\n            public <#= sn #>Enumerator()\n            {\n                PopulateCurrent();\n            }\n        }\n        #endregion\n\n        #region Enumerable\n        private class <#= sn #>Enumerable : IEnumerable, IEnumerable<<#= sn #>>\n        {\n            #region IEnumerable implementation\n            public IEnumerator GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n\n            IEnumerator<<#= sn #>> IEnumerable<<#= sn #>>.GetEnumerator()\n            {\n                return new <#= sn #>Enumerator();\n            }\n            #endregion\n        }\n        #endregion\n\n        static public IEnumerable<<#= sn #>> Sequence()\n        {\n            return new <#= sn #>Enumerable();\n        }\n    }\n<#+\n        }\n    } // sbf\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::visual_studio::project",
      "documentation": "Generates visual studio project.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_project",
        "masd.wale.kvp.archetype.simple_name": "project",
        "masd.physical.part_id": "masd.csharp.implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.visual_studio",
        "masd.physical.wale_template_reference": "csharp_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "xml"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/project.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/visual_studio/project_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/visual_studio/project_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid project_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"project\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::visual_studio::project;\n    const auto& proj(ast.as<project>(e));\n\n#>\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"4.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Debug</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProjectGuid>{<#= proj.guid() #>}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <RootNamespace><#= proj.project_name() #></RootNamespace>\n    <AssemblyName><#= proj.project_name() #></AssemblyName>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug</OutputPath>\n    <DefineConstants>DEBUG;</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <DebugType>full</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <ConsolePause>false</ConsolePause>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"System\" />\n  </ItemGroup>\n<#+\n        for (const auto& ig : proj.item_groups()) {\n#>\n  <ItemGroup>\n<#+\n            for (const auto& i : ig.items())\n#>\n    <<#= i.name() #> Include=\"<#= i.include() #>\" />\n  </ItemGroup>\n<#+\n        }\n#>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CSharp.targets\" />\n</Project>\n<#+\n    ast.update_artefact();\n    stp.end_transform(a);\n\n}\n#>\n"
        }
      ]
    },
    {
      "name": "transforms::csharp::visual_studio::solution",
      "documentation": "Generates visual studio solutions.\n",
      "stereotypes": [
        "masd::physical::archetype"
      ],
      "tagged_values": {
        "masd.physical.logical_meta_element_id": "dogen.logical.entities.visual_studio_solution",
        "masd.wale.kvp.archetype.simple_name": "solution",
        "masd.physical.part_id": "masd.csharp.implementation",
        "masd.wale.kvp.containing_namespace": "text.transforms.visual_studio",
        "masd.physical.wale_template_reference": "csharp_transform_implementation",
        "masd.physical.relation_status": "not_relatable",
        "masd.physical.technical_space": "sln"
      },
      "fallback_element_type": "masd::object",
      "attributes": [
        {
          "name": "stitch_template_content",
          "type": "",
          "documentation": "<#@ masd.stitch.stream_variable_name=ast.stream() #>\n<#@ masd.stitch.containing_namespaces=dogen::text::transforms::csharp::visual_studio #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/io/shared_ptr_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/log/logger.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.tracing/types/scoped_tracer.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/io/entities/element_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.physical/io/entities/artefact_io.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=<boost/make_shared.hpp> #>\n<#@ masd.stitch.inclusion_dependency=<boost/algorithm/string/join.hpp> #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.utility/types/formatters/sequence_formatter.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/physical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.identification/types/helpers/logical_meta_name_factory.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.logical/types/entities/visual_studio/solution.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/formatters/assistant.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/visual_studio/solution_transform.hpp\" #>\n<#@ masd.stitch.inclusion_dependency=\"dogen.text/types/transforms/csharp/visual_studio/solution_factory.hpp\" #>\n<#$ stitch.wale.template_instantiation_result #>\n<#+\n\nvoid solution_transform::\napply(const text::transforms::context& ctx, const text::entities::model& lps,\n    const logical::entities::element& e, physical::entities::artefact& a) const {\n    tracing::scoped_transform_tracer stp(lg, \"solution\",\n        transform_id, e.name().qualified().dot(), *ctx.tracer(), e);\n\n    text::formatters::assistant ast(lps, e, a, false/*requires_header_guard*/);\n    using logical::entities::visual_studio::solution;\n    const auto& sln(ast.as<solution>(e));\n#>\nMicrosoft Visual Studio Solution File, Format Version 12.00\n# Visual Studio 2012\n<#+\n    for (const auto& ppb : sln.project_persistence_blocks()) {\n#>\nProject(\"{<#= ppb.type_guid() #>}\") = \"<#= ppb.name() #>\", \"<#= ppb.name() #>.csproj\", \"{<#= ppb.guid() #>}\"\nEndProject\n<#+\n    }\n#>\nGlobal\n    GlobalSection(SolutionConfigurationPlatforms) = preSolution\n        Debug|Any CPU = Debug|Any CPU\n        Release|Any CPU = Release|Any CPU\n    EndGlobalSection\n    GlobalSection(ProjectConfigurationPlatforms) = postSolution\n<#+\n    for (const auto& ppb : sln.project_persistence_blocks()) {\n#>\n        {<#= ppb.guid() #>}.Debug|Any CPU.ActiveCfg = Debug|Any CPU\n        {<#= ppb.guid() #>}.Debug|Any CPU.Build.0 = Debug|Any CPU\n        {<#= ppb.guid() #>}.Release|Any CPU.ActiveCfg = Release|Any CPU\n        {<#= ppb.guid() #>}.Release|Any CPU.Build.0 = Release|Any CPU\n<#+\n    }\n#>\n    EndGlobalSection\n    GlobalSection(MonoDevelopProperties) = preSolution\n        StartupItem = CSharpModel.csproj\n    EndGlobalSection\nEndGlobal\n<#+\n    ast.update_artefact();\n    stp.end_transform(a);\n}\n#>\n"
        }
      ]
    }
  ]
}
